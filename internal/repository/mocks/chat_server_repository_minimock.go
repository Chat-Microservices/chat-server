// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/semho/chat-microservices/chat-server/internal/repository.ChatServerRepository -o chat_server_repository_minimock.go -n ChatServerRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/semho/chat-microservices/chat-server/internal/client/db"
	"github.com/semho/chat-microservices/chat-server/internal/model"
)

// ChatServerRepositoryMock implements repository.ChatServerRepository
type ChatServerRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBindUserToChat          func(ctx context.Context, usersID []int64, chatID int64) (qa1 []db.Query, err error)
	inspectFuncBindUserToChat   func(ctx context.Context, usersID []int64, chatID int64)
	afterBindUserToChatCounter  uint64
	beforeBindUserToChatCounter uint64
	BindUserToChatMock          mChatServerRepositoryMockBindUserToChat

	funcChatExists          func(ctx context.Context, chatID int64) (b1 bool, err error)
	inspectFuncChatExists   func(ctx context.Context, chatID int64)
	afterChatExistsCounter  uint64
	beforeChatExistsCounter uint64
	ChatExistsMock          mChatServerRepositoryMockChatExists

	funcCreateChat          func(ctx context.Context) (i1 int64, q1 db.Query, err error)
	inspectFuncCreateChat   func(ctx context.Context)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatServerRepositoryMockCreateChat

	funcCreateLog          func(ctx context.Context, logger *model.Log) (err error)
	inspectFuncCreateLog   func(ctx context.Context, logger *model.Log)
	afterCreateLogCounter  uint64
	beforeCreateLogCounter uint64
	CreateLogMock          mChatServerRepositoryMockCreateLog

	funcDeleteBindUserFromChat          func(ctx context.Context, chatID int64) (q1 db.Query, err error)
	inspectFuncDeleteBindUserFromChat   func(ctx context.Context, chatID int64)
	afterDeleteBindUserFromChatCounter  uint64
	beforeDeleteBindUserFromChatCounter uint64
	DeleteBindUserFromChatMock          mChatServerRepositoryMockDeleteBindUserFromChat

	funcDeleteChat          func(ctx context.Context, chatID int64) (q1 db.Query, err error)
	inspectFuncDeleteChat   func(ctx context.Context, chatID int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatServerRepositoryMockDeleteChat

	funcDeleteMessageFromChat          func(ctx context.Context, chatID int64) (q1 db.Query, err error)
	inspectFuncDeleteMessageFromChat   func(ctx context.Context, chatID int64)
	afterDeleteMessageFromChatCounter  uint64
	beforeDeleteMessageFromChatCounter uint64
	DeleteMessageFromChatMock          mChatServerRepositoryMockDeleteMessageFromChat

	funcGetListLog          func(ctx context.Context, pageNumber uint64, pageSize uint64) (lpa1 []*model.Log, err error)
	inspectFuncGetListLog   func(ctx context.Context, pageNumber uint64, pageSize uint64)
	afterGetListLogCounter  uint64
	beforeGetListLogCounter uint64
	GetListLogMock          mChatServerRepositoryMockGetListLog

	funcGetOfCreateUsers          func(ctx context.Context, users []*model.User) (ia1 []int64, qa1 []db.Query, err error)
	inspectFuncGetOfCreateUsers   func(ctx context.Context, users []*model.User)
	afterGetOfCreateUsersCounter  uint64
	beforeGetOfCreateUsersCounter uint64
	GetOfCreateUsersMock          mChatServerRepositoryMockGetOfCreateUsers

	funcGetUserIDByName          func(ctx context.Context, name string) (i1 int64, q1 db.Query, err error)
	inspectFuncGetUserIDByName   func(ctx context.Context, name string)
	afterGetUserIDByNameCounter  uint64
	beforeGetUserIDByNameCounter uint64
	GetUserIDByNameMock          mChatServerRepositoryMockGetUserIDByName

	funcSendMessage          func(ctx context.Context, message *model.Message, userID int64) (q1 db.Query, err error)
	inspectFuncSendMessage   func(ctx context.Context, message *model.Message, userID int64)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatServerRepositoryMockSendMessage
}

// NewChatServerRepositoryMock returns a mock for repository.ChatServerRepository
func NewChatServerRepositoryMock(t minimock.Tester) *ChatServerRepositoryMock {
	m := &ChatServerRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BindUserToChatMock = mChatServerRepositoryMockBindUserToChat{mock: m}
	m.BindUserToChatMock.callArgs = []*ChatServerRepositoryMockBindUserToChatParams{}

	m.ChatExistsMock = mChatServerRepositoryMockChatExists{mock: m}
	m.ChatExistsMock.callArgs = []*ChatServerRepositoryMockChatExistsParams{}

	m.CreateChatMock = mChatServerRepositoryMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatServerRepositoryMockCreateChatParams{}

	m.CreateLogMock = mChatServerRepositoryMockCreateLog{mock: m}
	m.CreateLogMock.callArgs = []*ChatServerRepositoryMockCreateLogParams{}

	m.DeleteBindUserFromChatMock = mChatServerRepositoryMockDeleteBindUserFromChat{mock: m}
	m.DeleteBindUserFromChatMock.callArgs = []*ChatServerRepositoryMockDeleteBindUserFromChatParams{}

	m.DeleteChatMock = mChatServerRepositoryMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatServerRepositoryMockDeleteChatParams{}

	m.DeleteMessageFromChatMock = mChatServerRepositoryMockDeleteMessageFromChat{mock: m}
	m.DeleteMessageFromChatMock.callArgs = []*ChatServerRepositoryMockDeleteMessageFromChatParams{}

	m.GetListLogMock = mChatServerRepositoryMockGetListLog{mock: m}
	m.GetListLogMock.callArgs = []*ChatServerRepositoryMockGetListLogParams{}

	m.GetOfCreateUsersMock = mChatServerRepositoryMockGetOfCreateUsers{mock: m}
	m.GetOfCreateUsersMock.callArgs = []*ChatServerRepositoryMockGetOfCreateUsersParams{}

	m.GetUserIDByNameMock = mChatServerRepositoryMockGetUserIDByName{mock: m}
	m.GetUserIDByNameMock.callArgs = []*ChatServerRepositoryMockGetUserIDByNameParams{}

	m.SendMessageMock = mChatServerRepositoryMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatServerRepositoryMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServerRepositoryMockBindUserToChat struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockBindUserToChatExpectation
	expectations       []*ChatServerRepositoryMockBindUserToChatExpectation

	callArgs []*ChatServerRepositoryMockBindUserToChatParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockBindUserToChatExpectation specifies expectation struct of the ChatServerRepository.BindUserToChat
type ChatServerRepositoryMockBindUserToChatExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockBindUserToChatParams
	results *ChatServerRepositoryMockBindUserToChatResults
	Counter uint64
}

// ChatServerRepositoryMockBindUserToChatParams contains parameters of the ChatServerRepository.BindUserToChat
type ChatServerRepositoryMockBindUserToChatParams struct {
	ctx     context.Context
	usersID []int64
	chatID  int64
}

// ChatServerRepositoryMockBindUserToChatResults contains results of the ChatServerRepository.BindUserToChat
type ChatServerRepositoryMockBindUserToChatResults struct {
	qa1 []db.Query
	err error
}

// Expect sets up expected params for ChatServerRepository.BindUserToChat
func (mmBindUserToChat *mChatServerRepositoryMockBindUserToChat) Expect(ctx context.Context, usersID []int64, chatID int64) *mChatServerRepositoryMockBindUserToChat {
	if mmBindUserToChat.mock.funcBindUserToChat != nil {
		mmBindUserToChat.mock.t.Fatalf("ChatServerRepositoryMock.BindUserToChat mock is already set by Set")
	}

	if mmBindUserToChat.defaultExpectation == nil {
		mmBindUserToChat.defaultExpectation = &ChatServerRepositoryMockBindUserToChatExpectation{}
	}

	mmBindUserToChat.defaultExpectation.params = &ChatServerRepositoryMockBindUserToChatParams{ctx, usersID, chatID}
	for _, e := range mmBindUserToChat.expectations {
		if minimock.Equal(e.params, mmBindUserToChat.defaultExpectation.params) {
			mmBindUserToChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBindUserToChat.defaultExpectation.params)
		}
	}

	return mmBindUserToChat
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.BindUserToChat
func (mmBindUserToChat *mChatServerRepositoryMockBindUserToChat) Inspect(f func(ctx context.Context, usersID []int64, chatID int64)) *mChatServerRepositoryMockBindUserToChat {
	if mmBindUserToChat.mock.inspectFuncBindUserToChat != nil {
		mmBindUserToChat.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.BindUserToChat")
	}

	mmBindUserToChat.mock.inspectFuncBindUserToChat = f

	return mmBindUserToChat
}

// Return sets up results that will be returned by ChatServerRepository.BindUserToChat
func (mmBindUserToChat *mChatServerRepositoryMockBindUserToChat) Return(qa1 []db.Query, err error) *ChatServerRepositoryMock {
	if mmBindUserToChat.mock.funcBindUserToChat != nil {
		mmBindUserToChat.mock.t.Fatalf("ChatServerRepositoryMock.BindUserToChat mock is already set by Set")
	}

	if mmBindUserToChat.defaultExpectation == nil {
		mmBindUserToChat.defaultExpectation = &ChatServerRepositoryMockBindUserToChatExpectation{mock: mmBindUserToChat.mock}
	}
	mmBindUserToChat.defaultExpectation.results = &ChatServerRepositoryMockBindUserToChatResults{qa1, err}
	return mmBindUserToChat.mock
}

// Set uses given function f to mock the ChatServerRepository.BindUserToChat method
func (mmBindUserToChat *mChatServerRepositoryMockBindUserToChat) Set(f func(ctx context.Context, usersID []int64, chatID int64) (qa1 []db.Query, err error)) *ChatServerRepositoryMock {
	if mmBindUserToChat.defaultExpectation != nil {
		mmBindUserToChat.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.BindUserToChat method")
	}

	if len(mmBindUserToChat.expectations) > 0 {
		mmBindUserToChat.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.BindUserToChat method")
	}

	mmBindUserToChat.mock.funcBindUserToChat = f
	return mmBindUserToChat.mock
}

// When sets expectation for the ChatServerRepository.BindUserToChat which will trigger the result defined by the following
// Then helper
func (mmBindUserToChat *mChatServerRepositoryMockBindUserToChat) When(ctx context.Context, usersID []int64, chatID int64) *ChatServerRepositoryMockBindUserToChatExpectation {
	if mmBindUserToChat.mock.funcBindUserToChat != nil {
		mmBindUserToChat.mock.t.Fatalf("ChatServerRepositoryMock.BindUserToChat mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockBindUserToChatExpectation{
		mock:   mmBindUserToChat.mock,
		params: &ChatServerRepositoryMockBindUserToChatParams{ctx, usersID, chatID},
	}
	mmBindUserToChat.expectations = append(mmBindUserToChat.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.BindUserToChat return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockBindUserToChatExpectation) Then(qa1 []db.Query, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockBindUserToChatResults{qa1, err}
	return e.mock
}

// BindUserToChat implements repository.ChatServerRepository
func (mmBindUserToChat *ChatServerRepositoryMock) BindUserToChat(ctx context.Context, usersID []int64, chatID int64) (qa1 []db.Query, err error) {
	mm_atomic.AddUint64(&mmBindUserToChat.beforeBindUserToChatCounter, 1)
	defer mm_atomic.AddUint64(&mmBindUserToChat.afterBindUserToChatCounter, 1)

	if mmBindUserToChat.inspectFuncBindUserToChat != nil {
		mmBindUserToChat.inspectFuncBindUserToChat(ctx, usersID, chatID)
	}

	mm_params := ChatServerRepositoryMockBindUserToChatParams{ctx, usersID, chatID}

	// Record call args
	mmBindUserToChat.BindUserToChatMock.mutex.Lock()
	mmBindUserToChat.BindUserToChatMock.callArgs = append(mmBindUserToChat.BindUserToChatMock.callArgs, &mm_params)
	mmBindUserToChat.BindUserToChatMock.mutex.Unlock()

	for _, e := range mmBindUserToChat.BindUserToChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.qa1, e.results.err
		}
	}

	if mmBindUserToChat.BindUserToChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBindUserToChat.BindUserToChatMock.defaultExpectation.Counter, 1)
		mm_want := mmBindUserToChat.BindUserToChatMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockBindUserToChatParams{ctx, usersID, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBindUserToChat.t.Errorf("ChatServerRepositoryMock.BindUserToChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBindUserToChat.BindUserToChatMock.defaultExpectation.results
		if mm_results == nil {
			mmBindUserToChat.t.Fatal("No results are set for the ChatServerRepositoryMock.BindUserToChat")
		}
		return (*mm_results).qa1, (*mm_results).err
	}
	if mmBindUserToChat.funcBindUserToChat != nil {
		return mmBindUserToChat.funcBindUserToChat(ctx, usersID, chatID)
	}
	mmBindUserToChat.t.Fatalf("Unexpected call to ChatServerRepositoryMock.BindUserToChat. %v %v %v", ctx, usersID, chatID)
	return
}

// BindUserToChatAfterCounter returns a count of finished ChatServerRepositoryMock.BindUserToChat invocations
func (mmBindUserToChat *ChatServerRepositoryMock) BindUserToChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBindUserToChat.afterBindUserToChatCounter)
}

// BindUserToChatBeforeCounter returns a count of ChatServerRepositoryMock.BindUserToChat invocations
func (mmBindUserToChat *ChatServerRepositoryMock) BindUserToChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBindUserToChat.beforeBindUserToChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.BindUserToChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBindUserToChat *mChatServerRepositoryMockBindUserToChat) Calls() []*ChatServerRepositoryMockBindUserToChatParams {
	mmBindUserToChat.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockBindUserToChatParams, len(mmBindUserToChat.callArgs))
	copy(argCopy, mmBindUserToChat.callArgs)

	mmBindUserToChat.mutex.RUnlock()

	return argCopy
}

// MinimockBindUserToChatDone returns true if the count of the BindUserToChat invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockBindUserToChatDone() bool {
	for _, e := range m.BindUserToChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BindUserToChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBindUserToChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBindUserToChat != nil && mm_atomic.LoadUint64(&m.afterBindUserToChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockBindUserToChatInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockBindUserToChatInspect() {
	for _, e := range m.BindUserToChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.BindUserToChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BindUserToChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBindUserToChatCounter) < 1 {
		if m.BindUserToChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.BindUserToChat")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.BindUserToChat with params: %#v", *m.BindUserToChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBindUserToChat != nil && mm_atomic.LoadUint64(&m.afterBindUserToChatCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.BindUserToChat")
	}
}

type mChatServerRepositoryMockChatExists struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockChatExistsExpectation
	expectations       []*ChatServerRepositoryMockChatExistsExpectation

	callArgs []*ChatServerRepositoryMockChatExistsParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockChatExistsExpectation specifies expectation struct of the ChatServerRepository.ChatExists
type ChatServerRepositoryMockChatExistsExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockChatExistsParams
	results *ChatServerRepositoryMockChatExistsResults
	Counter uint64
}

// ChatServerRepositoryMockChatExistsParams contains parameters of the ChatServerRepository.ChatExists
type ChatServerRepositoryMockChatExistsParams struct {
	ctx    context.Context
	chatID int64
}

// ChatServerRepositoryMockChatExistsResults contains results of the ChatServerRepository.ChatExists
type ChatServerRepositoryMockChatExistsResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for ChatServerRepository.ChatExists
func (mmChatExists *mChatServerRepositoryMockChatExists) Expect(ctx context.Context, chatID int64) *mChatServerRepositoryMockChatExists {
	if mmChatExists.mock.funcChatExists != nil {
		mmChatExists.mock.t.Fatalf("ChatServerRepositoryMock.ChatExists mock is already set by Set")
	}

	if mmChatExists.defaultExpectation == nil {
		mmChatExists.defaultExpectation = &ChatServerRepositoryMockChatExistsExpectation{}
	}

	mmChatExists.defaultExpectation.params = &ChatServerRepositoryMockChatExistsParams{ctx, chatID}
	for _, e := range mmChatExists.expectations {
		if minimock.Equal(e.params, mmChatExists.defaultExpectation.params) {
			mmChatExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChatExists.defaultExpectation.params)
		}
	}

	return mmChatExists
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.ChatExists
func (mmChatExists *mChatServerRepositoryMockChatExists) Inspect(f func(ctx context.Context, chatID int64)) *mChatServerRepositoryMockChatExists {
	if mmChatExists.mock.inspectFuncChatExists != nil {
		mmChatExists.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.ChatExists")
	}

	mmChatExists.mock.inspectFuncChatExists = f

	return mmChatExists
}

// Return sets up results that will be returned by ChatServerRepository.ChatExists
func (mmChatExists *mChatServerRepositoryMockChatExists) Return(b1 bool, err error) *ChatServerRepositoryMock {
	if mmChatExists.mock.funcChatExists != nil {
		mmChatExists.mock.t.Fatalf("ChatServerRepositoryMock.ChatExists mock is already set by Set")
	}

	if mmChatExists.defaultExpectation == nil {
		mmChatExists.defaultExpectation = &ChatServerRepositoryMockChatExistsExpectation{mock: mmChatExists.mock}
	}
	mmChatExists.defaultExpectation.results = &ChatServerRepositoryMockChatExistsResults{b1, err}
	return mmChatExists.mock
}

// Set uses given function f to mock the ChatServerRepository.ChatExists method
func (mmChatExists *mChatServerRepositoryMockChatExists) Set(f func(ctx context.Context, chatID int64) (b1 bool, err error)) *ChatServerRepositoryMock {
	if mmChatExists.defaultExpectation != nil {
		mmChatExists.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.ChatExists method")
	}

	if len(mmChatExists.expectations) > 0 {
		mmChatExists.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.ChatExists method")
	}

	mmChatExists.mock.funcChatExists = f
	return mmChatExists.mock
}

// When sets expectation for the ChatServerRepository.ChatExists which will trigger the result defined by the following
// Then helper
func (mmChatExists *mChatServerRepositoryMockChatExists) When(ctx context.Context, chatID int64) *ChatServerRepositoryMockChatExistsExpectation {
	if mmChatExists.mock.funcChatExists != nil {
		mmChatExists.mock.t.Fatalf("ChatServerRepositoryMock.ChatExists mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockChatExistsExpectation{
		mock:   mmChatExists.mock,
		params: &ChatServerRepositoryMockChatExistsParams{ctx, chatID},
	}
	mmChatExists.expectations = append(mmChatExists.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.ChatExists return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockChatExistsExpectation) Then(b1 bool, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockChatExistsResults{b1, err}
	return e.mock
}

// ChatExists implements repository.ChatServerRepository
func (mmChatExists *ChatServerRepositoryMock) ChatExists(ctx context.Context, chatID int64) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmChatExists.beforeChatExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmChatExists.afterChatExistsCounter, 1)

	if mmChatExists.inspectFuncChatExists != nil {
		mmChatExists.inspectFuncChatExists(ctx, chatID)
	}

	mm_params := ChatServerRepositoryMockChatExistsParams{ctx, chatID}

	// Record call args
	mmChatExists.ChatExistsMock.mutex.Lock()
	mmChatExists.ChatExistsMock.callArgs = append(mmChatExists.ChatExistsMock.callArgs, &mm_params)
	mmChatExists.ChatExistsMock.mutex.Unlock()

	for _, e := range mmChatExists.ChatExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmChatExists.ChatExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChatExists.ChatExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmChatExists.ChatExistsMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockChatExistsParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChatExists.t.Errorf("ChatServerRepositoryMock.ChatExists got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChatExists.ChatExistsMock.defaultExpectation.results
		if mm_results == nil {
			mmChatExists.t.Fatal("No results are set for the ChatServerRepositoryMock.ChatExists")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmChatExists.funcChatExists != nil {
		return mmChatExists.funcChatExists(ctx, chatID)
	}
	mmChatExists.t.Fatalf("Unexpected call to ChatServerRepositoryMock.ChatExists. %v %v", ctx, chatID)
	return
}

// ChatExistsAfterCounter returns a count of finished ChatServerRepositoryMock.ChatExists invocations
func (mmChatExists *ChatServerRepositoryMock) ChatExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChatExists.afterChatExistsCounter)
}

// ChatExistsBeforeCounter returns a count of ChatServerRepositoryMock.ChatExists invocations
func (mmChatExists *ChatServerRepositoryMock) ChatExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChatExists.beforeChatExistsCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.ChatExists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChatExists *mChatServerRepositoryMockChatExists) Calls() []*ChatServerRepositoryMockChatExistsParams {
	mmChatExists.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockChatExistsParams, len(mmChatExists.callArgs))
	copy(argCopy, mmChatExists.callArgs)

	mmChatExists.mutex.RUnlock()

	return argCopy
}

// MinimockChatExistsDone returns true if the count of the ChatExists invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockChatExistsDone() bool {
	for _, e := range m.ChatExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChatExistsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChatExistsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChatExists != nil && mm_atomic.LoadUint64(&m.afterChatExistsCounter) < 1 {
		return false
	}
	return true
}

// MinimockChatExistsInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockChatExistsInspect() {
	for _, e := range m.ChatExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ChatExists with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChatExistsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChatExistsCounter) < 1 {
		if m.ChatExistsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.ChatExists")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ChatExists with params: %#v", *m.ChatExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChatExists != nil && mm_atomic.LoadUint64(&m.afterChatExistsCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.ChatExists")
	}
}

type mChatServerRepositoryMockCreateChat struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockCreateChatExpectation
	expectations       []*ChatServerRepositoryMockCreateChatExpectation

	callArgs []*ChatServerRepositoryMockCreateChatParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockCreateChatExpectation specifies expectation struct of the ChatServerRepository.CreateChat
type ChatServerRepositoryMockCreateChatExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockCreateChatParams
	results *ChatServerRepositoryMockCreateChatResults
	Counter uint64
}

// ChatServerRepositoryMockCreateChatParams contains parameters of the ChatServerRepository.CreateChat
type ChatServerRepositoryMockCreateChatParams struct {
	ctx context.Context
}

// ChatServerRepositoryMockCreateChatResults contains results of the ChatServerRepository.CreateChat
type ChatServerRepositoryMockCreateChatResults struct {
	i1  int64
	q1  db.Query
	err error
}

// Expect sets up expected params for ChatServerRepository.CreateChat
func (mmCreateChat *mChatServerRepositoryMockCreateChat) Expect(ctx context.Context) *mChatServerRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServerRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServerRepositoryMockCreateChatExpectation{}
	}

	mmCreateChat.defaultExpectation.params = &ChatServerRepositoryMockCreateChatParams{ctx}
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.CreateChat
func (mmCreateChat *mChatServerRepositoryMockCreateChat) Inspect(f func(ctx context.Context)) *mChatServerRepositoryMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatServerRepository.CreateChat
func (mmCreateChat *mChatServerRepositoryMockCreateChat) Return(i1 int64, q1 db.Query, err error) *ChatServerRepositoryMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServerRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServerRepositoryMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatServerRepositoryMockCreateChatResults{i1, q1, err}
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatServerRepository.CreateChat method
func (mmCreateChat *mChatServerRepositoryMockCreateChat) Set(f func(ctx context.Context) (i1 int64, q1 db.Query, err error)) *ChatServerRepositoryMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	return mmCreateChat.mock
}

// When sets expectation for the ChatServerRepository.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatServerRepositoryMockCreateChat) When(ctx context.Context) *ChatServerRepositoryMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServerRepositoryMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockCreateChatExpectation{
		mock:   mmCreateChat.mock,
		params: &ChatServerRepositoryMockCreateChatParams{ctx},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockCreateChatExpectation) Then(i1 int64, q1 db.Query, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockCreateChatResults{i1, q1, err}
	return e.mock
}

// CreateChat implements repository.ChatServerRepository
func (mmCreateChat *ChatServerRepositoryMock) CreateChat(ctx context.Context) (i1 int64, q1 db.Query, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx)
	}

	mm_params := ChatServerRepositoryMockCreateChatParams{ctx}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.q1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockCreateChatParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatServerRepositoryMock.CreateChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatServerRepositoryMock.CreateChat")
		}
		return (*mm_results).i1, (*mm_results).q1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatServerRepositoryMock.CreateChat. %v", ctx)
	return
}

// CreateChatAfterCounter returns a count of finished ChatServerRepositoryMock.CreateChat invocations
func (mmCreateChat *ChatServerRepositoryMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatServerRepositoryMock.CreateChat invocations
func (mmCreateChat *ChatServerRepositoryMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatServerRepositoryMockCreateChat) Calls() []*ChatServerRepositoryMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockCreateChatDone() bool {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.CreateChat")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateChat with params: %#v", *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.CreateChat")
	}
}

type mChatServerRepositoryMockCreateLog struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockCreateLogExpectation
	expectations       []*ChatServerRepositoryMockCreateLogExpectation

	callArgs []*ChatServerRepositoryMockCreateLogParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockCreateLogExpectation specifies expectation struct of the ChatServerRepository.CreateLog
type ChatServerRepositoryMockCreateLogExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockCreateLogParams
	results *ChatServerRepositoryMockCreateLogResults
	Counter uint64
}

// ChatServerRepositoryMockCreateLogParams contains parameters of the ChatServerRepository.CreateLog
type ChatServerRepositoryMockCreateLogParams struct {
	ctx    context.Context
	logger *model.Log
}

// ChatServerRepositoryMockCreateLogResults contains results of the ChatServerRepository.CreateLog
type ChatServerRepositoryMockCreateLogResults struct {
	err error
}

// Expect sets up expected params for ChatServerRepository.CreateLog
func (mmCreateLog *mChatServerRepositoryMockCreateLog) Expect(ctx context.Context, logger *model.Log) *mChatServerRepositoryMockCreateLog {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("ChatServerRepositoryMock.CreateLog mock is already set by Set")
	}

	if mmCreateLog.defaultExpectation == nil {
		mmCreateLog.defaultExpectation = &ChatServerRepositoryMockCreateLogExpectation{}
	}

	mmCreateLog.defaultExpectation.params = &ChatServerRepositoryMockCreateLogParams{ctx, logger}
	for _, e := range mmCreateLog.expectations {
		if minimock.Equal(e.params, mmCreateLog.defaultExpectation.params) {
			mmCreateLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateLog.defaultExpectation.params)
		}
	}

	return mmCreateLog
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.CreateLog
func (mmCreateLog *mChatServerRepositoryMockCreateLog) Inspect(f func(ctx context.Context, logger *model.Log)) *mChatServerRepositoryMockCreateLog {
	if mmCreateLog.mock.inspectFuncCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.CreateLog")
	}

	mmCreateLog.mock.inspectFuncCreateLog = f

	return mmCreateLog
}

// Return sets up results that will be returned by ChatServerRepository.CreateLog
func (mmCreateLog *mChatServerRepositoryMockCreateLog) Return(err error) *ChatServerRepositoryMock {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("ChatServerRepositoryMock.CreateLog mock is already set by Set")
	}

	if mmCreateLog.defaultExpectation == nil {
		mmCreateLog.defaultExpectation = &ChatServerRepositoryMockCreateLogExpectation{mock: mmCreateLog.mock}
	}
	mmCreateLog.defaultExpectation.results = &ChatServerRepositoryMockCreateLogResults{err}
	return mmCreateLog.mock
}

// Set uses given function f to mock the ChatServerRepository.CreateLog method
func (mmCreateLog *mChatServerRepositoryMockCreateLog) Set(f func(ctx context.Context, logger *model.Log) (err error)) *ChatServerRepositoryMock {
	if mmCreateLog.defaultExpectation != nil {
		mmCreateLog.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.CreateLog method")
	}

	if len(mmCreateLog.expectations) > 0 {
		mmCreateLog.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.CreateLog method")
	}

	mmCreateLog.mock.funcCreateLog = f
	return mmCreateLog.mock
}

// When sets expectation for the ChatServerRepository.CreateLog which will trigger the result defined by the following
// Then helper
func (mmCreateLog *mChatServerRepositoryMockCreateLog) When(ctx context.Context, logger *model.Log) *ChatServerRepositoryMockCreateLogExpectation {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("ChatServerRepositoryMock.CreateLog mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockCreateLogExpectation{
		mock:   mmCreateLog.mock,
		params: &ChatServerRepositoryMockCreateLogParams{ctx, logger},
	}
	mmCreateLog.expectations = append(mmCreateLog.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.CreateLog return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockCreateLogExpectation) Then(err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockCreateLogResults{err}
	return e.mock
}

// CreateLog implements repository.ChatServerRepository
func (mmCreateLog *ChatServerRepositoryMock) CreateLog(ctx context.Context, logger *model.Log) (err error) {
	mm_atomic.AddUint64(&mmCreateLog.beforeCreateLogCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateLog.afterCreateLogCounter, 1)

	if mmCreateLog.inspectFuncCreateLog != nil {
		mmCreateLog.inspectFuncCreateLog(ctx, logger)
	}

	mm_params := ChatServerRepositoryMockCreateLogParams{ctx, logger}

	// Record call args
	mmCreateLog.CreateLogMock.mutex.Lock()
	mmCreateLog.CreateLogMock.callArgs = append(mmCreateLog.CreateLogMock.callArgs, &mm_params)
	mmCreateLog.CreateLogMock.mutex.Unlock()

	for _, e := range mmCreateLog.CreateLogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateLog.CreateLogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateLog.CreateLogMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateLog.CreateLogMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockCreateLogParams{ctx, logger}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateLog.t.Errorf("ChatServerRepositoryMock.CreateLog got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateLog.CreateLogMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateLog.t.Fatal("No results are set for the ChatServerRepositoryMock.CreateLog")
		}
		return (*mm_results).err
	}
	if mmCreateLog.funcCreateLog != nil {
		return mmCreateLog.funcCreateLog(ctx, logger)
	}
	mmCreateLog.t.Fatalf("Unexpected call to ChatServerRepositoryMock.CreateLog. %v %v", ctx, logger)
	return
}

// CreateLogAfterCounter returns a count of finished ChatServerRepositoryMock.CreateLog invocations
func (mmCreateLog *ChatServerRepositoryMock) CreateLogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateLog.afterCreateLogCounter)
}

// CreateLogBeforeCounter returns a count of ChatServerRepositoryMock.CreateLog invocations
func (mmCreateLog *ChatServerRepositoryMock) CreateLogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateLog.beforeCreateLogCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.CreateLog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateLog *mChatServerRepositoryMockCreateLog) Calls() []*ChatServerRepositoryMockCreateLogParams {
	mmCreateLog.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockCreateLogParams, len(mmCreateLog.callArgs))
	copy(argCopy, mmCreateLog.callArgs)

	mmCreateLog.mutex.RUnlock()

	return argCopy
}

// MinimockCreateLogDone returns true if the count of the CreateLog invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockCreateLogDone() bool {
	for _, e := range m.CreateLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateLogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateLogCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateLog != nil && mm_atomic.LoadUint64(&m.afterCreateLogCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateLogInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockCreateLogInspect() {
	for _, e := range m.CreateLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateLog with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateLogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateLogCounter) < 1 {
		if m.CreateLogMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.CreateLog")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateLog with params: %#v", *m.CreateLogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateLog != nil && mm_atomic.LoadUint64(&m.afterCreateLogCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.CreateLog")
	}
}

type mChatServerRepositoryMockDeleteBindUserFromChat struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockDeleteBindUserFromChatExpectation
	expectations       []*ChatServerRepositoryMockDeleteBindUserFromChatExpectation

	callArgs []*ChatServerRepositoryMockDeleteBindUserFromChatParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockDeleteBindUserFromChatExpectation specifies expectation struct of the ChatServerRepository.DeleteBindUserFromChat
type ChatServerRepositoryMockDeleteBindUserFromChatExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockDeleteBindUserFromChatParams
	results *ChatServerRepositoryMockDeleteBindUserFromChatResults
	Counter uint64
}

// ChatServerRepositoryMockDeleteBindUserFromChatParams contains parameters of the ChatServerRepository.DeleteBindUserFromChat
type ChatServerRepositoryMockDeleteBindUserFromChatParams struct {
	ctx    context.Context
	chatID int64
}

// ChatServerRepositoryMockDeleteBindUserFromChatResults contains results of the ChatServerRepository.DeleteBindUserFromChat
type ChatServerRepositoryMockDeleteBindUserFromChatResults struct {
	q1  db.Query
	err error
}

// Expect sets up expected params for ChatServerRepository.DeleteBindUserFromChat
func (mmDeleteBindUserFromChat *mChatServerRepositoryMockDeleteBindUserFromChat) Expect(ctx context.Context, chatID int64) *mChatServerRepositoryMockDeleteBindUserFromChat {
	if mmDeleteBindUserFromChat.mock.funcDeleteBindUserFromChat != nil {
		mmDeleteBindUserFromChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteBindUserFromChat mock is already set by Set")
	}

	if mmDeleteBindUserFromChat.defaultExpectation == nil {
		mmDeleteBindUserFromChat.defaultExpectation = &ChatServerRepositoryMockDeleteBindUserFromChatExpectation{}
	}

	mmDeleteBindUserFromChat.defaultExpectation.params = &ChatServerRepositoryMockDeleteBindUserFromChatParams{ctx, chatID}
	for _, e := range mmDeleteBindUserFromChat.expectations {
		if minimock.Equal(e.params, mmDeleteBindUserFromChat.defaultExpectation.params) {
			mmDeleteBindUserFromChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteBindUserFromChat.defaultExpectation.params)
		}
	}

	return mmDeleteBindUserFromChat
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.DeleteBindUserFromChat
func (mmDeleteBindUserFromChat *mChatServerRepositoryMockDeleteBindUserFromChat) Inspect(f func(ctx context.Context, chatID int64)) *mChatServerRepositoryMockDeleteBindUserFromChat {
	if mmDeleteBindUserFromChat.mock.inspectFuncDeleteBindUserFromChat != nil {
		mmDeleteBindUserFromChat.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.DeleteBindUserFromChat")
	}

	mmDeleteBindUserFromChat.mock.inspectFuncDeleteBindUserFromChat = f

	return mmDeleteBindUserFromChat
}

// Return sets up results that will be returned by ChatServerRepository.DeleteBindUserFromChat
func (mmDeleteBindUserFromChat *mChatServerRepositoryMockDeleteBindUserFromChat) Return(q1 db.Query, err error) *ChatServerRepositoryMock {
	if mmDeleteBindUserFromChat.mock.funcDeleteBindUserFromChat != nil {
		mmDeleteBindUserFromChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteBindUserFromChat mock is already set by Set")
	}

	if mmDeleteBindUserFromChat.defaultExpectation == nil {
		mmDeleteBindUserFromChat.defaultExpectation = &ChatServerRepositoryMockDeleteBindUserFromChatExpectation{mock: mmDeleteBindUserFromChat.mock}
	}
	mmDeleteBindUserFromChat.defaultExpectation.results = &ChatServerRepositoryMockDeleteBindUserFromChatResults{q1, err}
	return mmDeleteBindUserFromChat.mock
}

// Set uses given function f to mock the ChatServerRepository.DeleteBindUserFromChat method
func (mmDeleteBindUserFromChat *mChatServerRepositoryMockDeleteBindUserFromChat) Set(f func(ctx context.Context, chatID int64) (q1 db.Query, err error)) *ChatServerRepositoryMock {
	if mmDeleteBindUserFromChat.defaultExpectation != nil {
		mmDeleteBindUserFromChat.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.DeleteBindUserFromChat method")
	}

	if len(mmDeleteBindUserFromChat.expectations) > 0 {
		mmDeleteBindUserFromChat.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.DeleteBindUserFromChat method")
	}

	mmDeleteBindUserFromChat.mock.funcDeleteBindUserFromChat = f
	return mmDeleteBindUserFromChat.mock
}

// When sets expectation for the ChatServerRepository.DeleteBindUserFromChat which will trigger the result defined by the following
// Then helper
func (mmDeleteBindUserFromChat *mChatServerRepositoryMockDeleteBindUserFromChat) When(ctx context.Context, chatID int64) *ChatServerRepositoryMockDeleteBindUserFromChatExpectation {
	if mmDeleteBindUserFromChat.mock.funcDeleteBindUserFromChat != nil {
		mmDeleteBindUserFromChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteBindUserFromChat mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockDeleteBindUserFromChatExpectation{
		mock:   mmDeleteBindUserFromChat.mock,
		params: &ChatServerRepositoryMockDeleteBindUserFromChatParams{ctx, chatID},
	}
	mmDeleteBindUserFromChat.expectations = append(mmDeleteBindUserFromChat.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.DeleteBindUserFromChat return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockDeleteBindUserFromChatExpectation) Then(q1 db.Query, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockDeleteBindUserFromChatResults{q1, err}
	return e.mock
}

// DeleteBindUserFromChat implements repository.ChatServerRepository
func (mmDeleteBindUserFromChat *ChatServerRepositoryMock) DeleteBindUserFromChat(ctx context.Context, chatID int64) (q1 db.Query, err error) {
	mm_atomic.AddUint64(&mmDeleteBindUserFromChat.beforeDeleteBindUserFromChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteBindUserFromChat.afterDeleteBindUserFromChatCounter, 1)

	if mmDeleteBindUserFromChat.inspectFuncDeleteBindUserFromChat != nil {
		mmDeleteBindUserFromChat.inspectFuncDeleteBindUserFromChat(ctx, chatID)
	}

	mm_params := ChatServerRepositoryMockDeleteBindUserFromChatParams{ctx, chatID}

	// Record call args
	mmDeleteBindUserFromChat.DeleteBindUserFromChatMock.mutex.Lock()
	mmDeleteBindUserFromChat.DeleteBindUserFromChatMock.callArgs = append(mmDeleteBindUserFromChat.DeleteBindUserFromChatMock.callArgs, &mm_params)
	mmDeleteBindUserFromChat.DeleteBindUserFromChatMock.mutex.Unlock()

	for _, e := range mmDeleteBindUserFromChat.DeleteBindUserFromChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.q1, e.results.err
		}
	}

	if mmDeleteBindUserFromChat.DeleteBindUserFromChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteBindUserFromChat.DeleteBindUserFromChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteBindUserFromChat.DeleteBindUserFromChatMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockDeleteBindUserFromChatParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteBindUserFromChat.t.Errorf("ChatServerRepositoryMock.DeleteBindUserFromChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteBindUserFromChat.DeleteBindUserFromChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteBindUserFromChat.t.Fatal("No results are set for the ChatServerRepositoryMock.DeleteBindUserFromChat")
		}
		return (*mm_results).q1, (*mm_results).err
	}
	if mmDeleteBindUserFromChat.funcDeleteBindUserFromChat != nil {
		return mmDeleteBindUserFromChat.funcDeleteBindUserFromChat(ctx, chatID)
	}
	mmDeleteBindUserFromChat.t.Fatalf("Unexpected call to ChatServerRepositoryMock.DeleteBindUserFromChat. %v %v", ctx, chatID)
	return
}

// DeleteBindUserFromChatAfterCounter returns a count of finished ChatServerRepositoryMock.DeleteBindUserFromChat invocations
func (mmDeleteBindUserFromChat *ChatServerRepositoryMock) DeleteBindUserFromChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBindUserFromChat.afterDeleteBindUserFromChatCounter)
}

// DeleteBindUserFromChatBeforeCounter returns a count of ChatServerRepositoryMock.DeleteBindUserFromChat invocations
func (mmDeleteBindUserFromChat *ChatServerRepositoryMock) DeleteBindUserFromChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBindUserFromChat.beforeDeleteBindUserFromChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.DeleteBindUserFromChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteBindUserFromChat *mChatServerRepositoryMockDeleteBindUserFromChat) Calls() []*ChatServerRepositoryMockDeleteBindUserFromChatParams {
	mmDeleteBindUserFromChat.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockDeleteBindUserFromChatParams, len(mmDeleteBindUserFromChat.callArgs))
	copy(argCopy, mmDeleteBindUserFromChat.callArgs)

	mmDeleteBindUserFromChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteBindUserFromChatDone returns true if the count of the DeleteBindUserFromChat invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockDeleteBindUserFromChatDone() bool {
	for _, e := range m.DeleteBindUserFromChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteBindUserFromChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteBindUserFromChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteBindUserFromChat != nil && mm_atomic.LoadUint64(&m.afterDeleteBindUserFromChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteBindUserFromChatInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockDeleteBindUserFromChatInspect() {
	for _, e := range m.DeleteBindUserFromChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteBindUserFromChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteBindUserFromChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteBindUserFromChatCounter) < 1 {
		if m.DeleteBindUserFromChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.DeleteBindUserFromChat")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteBindUserFromChat with params: %#v", *m.DeleteBindUserFromChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteBindUserFromChat != nil && mm_atomic.LoadUint64(&m.afterDeleteBindUserFromChatCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.DeleteBindUserFromChat")
	}
}

type mChatServerRepositoryMockDeleteChat struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockDeleteChatExpectation
	expectations       []*ChatServerRepositoryMockDeleteChatExpectation

	callArgs []*ChatServerRepositoryMockDeleteChatParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockDeleteChatExpectation specifies expectation struct of the ChatServerRepository.DeleteChat
type ChatServerRepositoryMockDeleteChatExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockDeleteChatParams
	results *ChatServerRepositoryMockDeleteChatResults
	Counter uint64
}

// ChatServerRepositoryMockDeleteChatParams contains parameters of the ChatServerRepository.DeleteChat
type ChatServerRepositoryMockDeleteChatParams struct {
	ctx    context.Context
	chatID int64
}

// ChatServerRepositoryMockDeleteChatResults contains results of the ChatServerRepository.DeleteChat
type ChatServerRepositoryMockDeleteChatResults struct {
	q1  db.Query
	err error
}

// Expect sets up expected params for ChatServerRepository.DeleteChat
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Expect(ctx context.Context, chatID int64) *mChatServerRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServerRepositoryMockDeleteChatExpectation{}
	}

	mmDeleteChat.defaultExpectation.params = &ChatServerRepositoryMockDeleteChatParams{ctx, chatID}
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.DeleteChat
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Inspect(f func(ctx context.Context, chatID int64)) *mChatServerRepositoryMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatServerRepository.DeleteChat
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Return(q1 db.Query, err error) *ChatServerRepositoryMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServerRepositoryMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatServerRepositoryMockDeleteChatResults{q1, err}
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatServerRepository.DeleteChat method
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Set(f func(ctx context.Context, chatID int64) (q1 db.Query, err error)) *ChatServerRepositoryMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	return mmDeleteChat.mock
}

// When sets expectation for the ChatServerRepository.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) When(ctx context.Context, chatID int64) *ChatServerRepositoryMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockDeleteChatExpectation{
		mock:   mmDeleteChat.mock,
		params: &ChatServerRepositoryMockDeleteChatParams{ctx, chatID},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockDeleteChatExpectation) Then(q1 db.Query, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockDeleteChatResults{q1, err}
	return e.mock
}

// DeleteChat implements repository.ChatServerRepository
func (mmDeleteChat *ChatServerRepositoryMock) DeleteChat(ctx context.Context, chatID int64) (q1 db.Query, err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, chatID)
	}

	mm_params := ChatServerRepositoryMockDeleteChatParams{ctx, chatID}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.q1, e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockDeleteChatParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatServerRepositoryMock.DeleteChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatServerRepositoryMock.DeleteChat")
		}
		return (*mm_results).q1, (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, chatID)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatServerRepositoryMock.DeleteChat. %v %v", ctx, chatID)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatServerRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatServerRepositoryMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatServerRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatServerRepositoryMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Calls() []*ChatServerRepositoryMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockDeleteChatDone() bool {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.DeleteChat")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChat with params: %#v", *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.DeleteChat")
	}
}

type mChatServerRepositoryMockDeleteMessageFromChat struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockDeleteMessageFromChatExpectation
	expectations       []*ChatServerRepositoryMockDeleteMessageFromChatExpectation

	callArgs []*ChatServerRepositoryMockDeleteMessageFromChatParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockDeleteMessageFromChatExpectation specifies expectation struct of the ChatServerRepository.DeleteMessageFromChat
type ChatServerRepositoryMockDeleteMessageFromChatExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockDeleteMessageFromChatParams
	results *ChatServerRepositoryMockDeleteMessageFromChatResults
	Counter uint64
}

// ChatServerRepositoryMockDeleteMessageFromChatParams contains parameters of the ChatServerRepository.DeleteMessageFromChat
type ChatServerRepositoryMockDeleteMessageFromChatParams struct {
	ctx    context.Context
	chatID int64
}

// ChatServerRepositoryMockDeleteMessageFromChatResults contains results of the ChatServerRepository.DeleteMessageFromChat
type ChatServerRepositoryMockDeleteMessageFromChatResults struct {
	q1  db.Query
	err error
}

// Expect sets up expected params for ChatServerRepository.DeleteMessageFromChat
func (mmDeleteMessageFromChat *mChatServerRepositoryMockDeleteMessageFromChat) Expect(ctx context.Context, chatID int64) *mChatServerRepositoryMockDeleteMessageFromChat {
	if mmDeleteMessageFromChat.mock.funcDeleteMessageFromChat != nil {
		mmDeleteMessageFromChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteMessageFromChat mock is already set by Set")
	}

	if mmDeleteMessageFromChat.defaultExpectation == nil {
		mmDeleteMessageFromChat.defaultExpectation = &ChatServerRepositoryMockDeleteMessageFromChatExpectation{}
	}

	mmDeleteMessageFromChat.defaultExpectation.params = &ChatServerRepositoryMockDeleteMessageFromChatParams{ctx, chatID}
	for _, e := range mmDeleteMessageFromChat.expectations {
		if minimock.Equal(e.params, mmDeleteMessageFromChat.defaultExpectation.params) {
			mmDeleteMessageFromChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteMessageFromChat.defaultExpectation.params)
		}
	}

	return mmDeleteMessageFromChat
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.DeleteMessageFromChat
func (mmDeleteMessageFromChat *mChatServerRepositoryMockDeleteMessageFromChat) Inspect(f func(ctx context.Context, chatID int64)) *mChatServerRepositoryMockDeleteMessageFromChat {
	if mmDeleteMessageFromChat.mock.inspectFuncDeleteMessageFromChat != nil {
		mmDeleteMessageFromChat.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.DeleteMessageFromChat")
	}

	mmDeleteMessageFromChat.mock.inspectFuncDeleteMessageFromChat = f

	return mmDeleteMessageFromChat
}

// Return sets up results that will be returned by ChatServerRepository.DeleteMessageFromChat
func (mmDeleteMessageFromChat *mChatServerRepositoryMockDeleteMessageFromChat) Return(q1 db.Query, err error) *ChatServerRepositoryMock {
	if mmDeleteMessageFromChat.mock.funcDeleteMessageFromChat != nil {
		mmDeleteMessageFromChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteMessageFromChat mock is already set by Set")
	}

	if mmDeleteMessageFromChat.defaultExpectation == nil {
		mmDeleteMessageFromChat.defaultExpectation = &ChatServerRepositoryMockDeleteMessageFromChatExpectation{mock: mmDeleteMessageFromChat.mock}
	}
	mmDeleteMessageFromChat.defaultExpectation.results = &ChatServerRepositoryMockDeleteMessageFromChatResults{q1, err}
	return mmDeleteMessageFromChat.mock
}

// Set uses given function f to mock the ChatServerRepository.DeleteMessageFromChat method
func (mmDeleteMessageFromChat *mChatServerRepositoryMockDeleteMessageFromChat) Set(f func(ctx context.Context, chatID int64) (q1 db.Query, err error)) *ChatServerRepositoryMock {
	if mmDeleteMessageFromChat.defaultExpectation != nil {
		mmDeleteMessageFromChat.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.DeleteMessageFromChat method")
	}

	if len(mmDeleteMessageFromChat.expectations) > 0 {
		mmDeleteMessageFromChat.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.DeleteMessageFromChat method")
	}

	mmDeleteMessageFromChat.mock.funcDeleteMessageFromChat = f
	return mmDeleteMessageFromChat.mock
}

// When sets expectation for the ChatServerRepository.DeleteMessageFromChat which will trigger the result defined by the following
// Then helper
func (mmDeleteMessageFromChat *mChatServerRepositoryMockDeleteMessageFromChat) When(ctx context.Context, chatID int64) *ChatServerRepositoryMockDeleteMessageFromChatExpectation {
	if mmDeleteMessageFromChat.mock.funcDeleteMessageFromChat != nil {
		mmDeleteMessageFromChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteMessageFromChat mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockDeleteMessageFromChatExpectation{
		mock:   mmDeleteMessageFromChat.mock,
		params: &ChatServerRepositoryMockDeleteMessageFromChatParams{ctx, chatID},
	}
	mmDeleteMessageFromChat.expectations = append(mmDeleteMessageFromChat.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.DeleteMessageFromChat return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockDeleteMessageFromChatExpectation) Then(q1 db.Query, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockDeleteMessageFromChatResults{q1, err}
	return e.mock
}

// DeleteMessageFromChat implements repository.ChatServerRepository
func (mmDeleteMessageFromChat *ChatServerRepositoryMock) DeleteMessageFromChat(ctx context.Context, chatID int64) (q1 db.Query, err error) {
	mm_atomic.AddUint64(&mmDeleteMessageFromChat.beforeDeleteMessageFromChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteMessageFromChat.afterDeleteMessageFromChatCounter, 1)

	if mmDeleteMessageFromChat.inspectFuncDeleteMessageFromChat != nil {
		mmDeleteMessageFromChat.inspectFuncDeleteMessageFromChat(ctx, chatID)
	}

	mm_params := ChatServerRepositoryMockDeleteMessageFromChatParams{ctx, chatID}

	// Record call args
	mmDeleteMessageFromChat.DeleteMessageFromChatMock.mutex.Lock()
	mmDeleteMessageFromChat.DeleteMessageFromChatMock.callArgs = append(mmDeleteMessageFromChat.DeleteMessageFromChatMock.callArgs, &mm_params)
	mmDeleteMessageFromChat.DeleteMessageFromChatMock.mutex.Unlock()

	for _, e := range mmDeleteMessageFromChat.DeleteMessageFromChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.q1, e.results.err
		}
	}

	if mmDeleteMessageFromChat.DeleteMessageFromChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteMessageFromChat.DeleteMessageFromChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteMessageFromChat.DeleteMessageFromChatMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockDeleteMessageFromChatParams{ctx, chatID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteMessageFromChat.t.Errorf("ChatServerRepositoryMock.DeleteMessageFromChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteMessageFromChat.DeleteMessageFromChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteMessageFromChat.t.Fatal("No results are set for the ChatServerRepositoryMock.DeleteMessageFromChat")
		}
		return (*mm_results).q1, (*mm_results).err
	}
	if mmDeleteMessageFromChat.funcDeleteMessageFromChat != nil {
		return mmDeleteMessageFromChat.funcDeleteMessageFromChat(ctx, chatID)
	}
	mmDeleteMessageFromChat.t.Fatalf("Unexpected call to ChatServerRepositoryMock.DeleteMessageFromChat. %v %v", ctx, chatID)
	return
}

// DeleteMessageFromChatAfterCounter returns a count of finished ChatServerRepositoryMock.DeleteMessageFromChat invocations
func (mmDeleteMessageFromChat *ChatServerRepositoryMock) DeleteMessageFromChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMessageFromChat.afterDeleteMessageFromChatCounter)
}

// DeleteMessageFromChatBeforeCounter returns a count of ChatServerRepositoryMock.DeleteMessageFromChat invocations
func (mmDeleteMessageFromChat *ChatServerRepositoryMock) DeleteMessageFromChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMessageFromChat.beforeDeleteMessageFromChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.DeleteMessageFromChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteMessageFromChat *mChatServerRepositoryMockDeleteMessageFromChat) Calls() []*ChatServerRepositoryMockDeleteMessageFromChatParams {
	mmDeleteMessageFromChat.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockDeleteMessageFromChatParams, len(mmDeleteMessageFromChat.callArgs))
	copy(argCopy, mmDeleteMessageFromChat.callArgs)

	mmDeleteMessageFromChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteMessageFromChatDone returns true if the count of the DeleteMessageFromChat invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockDeleteMessageFromChatDone() bool {
	for _, e := range m.DeleteMessageFromChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMessageFromChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteMessageFromChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteMessageFromChat != nil && mm_atomic.LoadUint64(&m.afterDeleteMessageFromChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteMessageFromChatInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockDeleteMessageFromChatInspect() {
	for _, e := range m.DeleteMessageFromChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteMessageFromChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMessageFromChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteMessageFromChatCounter) < 1 {
		if m.DeleteMessageFromChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.DeleteMessageFromChat")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteMessageFromChat with params: %#v", *m.DeleteMessageFromChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteMessageFromChat != nil && mm_atomic.LoadUint64(&m.afterDeleteMessageFromChatCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.DeleteMessageFromChat")
	}
}

type mChatServerRepositoryMockGetListLog struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockGetListLogExpectation
	expectations       []*ChatServerRepositoryMockGetListLogExpectation

	callArgs []*ChatServerRepositoryMockGetListLogParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockGetListLogExpectation specifies expectation struct of the ChatServerRepository.GetListLog
type ChatServerRepositoryMockGetListLogExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockGetListLogParams
	results *ChatServerRepositoryMockGetListLogResults
	Counter uint64
}

// ChatServerRepositoryMockGetListLogParams contains parameters of the ChatServerRepository.GetListLog
type ChatServerRepositoryMockGetListLogParams struct {
	ctx        context.Context
	pageNumber uint64
	pageSize   uint64
}

// ChatServerRepositoryMockGetListLogResults contains results of the ChatServerRepository.GetListLog
type ChatServerRepositoryMockGetListLogResults struct {
	lpa1 []*model.Log
	err  error
}

// Expect sets up expected params for ChatServerRepository.GetListLog
func (mmGetListLog *mChatServerRepositoryMockGetListLog) Expect(ctx context.Context, pageNumber uint64, pageSize uint64) *mChatServerRepositoryMockGetListLog {
	if mmGetListLog.mock.funcGetListLog != nil {
		mmGetListLog.mock.t.Fatalf("ChatServerRepositoryMock.GetListLog mock is already set by Set")
	}

	if mmGetListLog.defaultExpectation == nil {
		mmGetListLog.defaultExpectation = &ChatServerRepositoryMockGetListLogExpectation{}
	}

	mmGetListLog.defaultExpectation.params = &ChatServerRepositoryMockGetListLogParams{ctx, pageNumber, pageSize}
	for _, e := range mmGetListLog.expectations {
		if minimock.Equal(e.params, mmGetListLog.defaultExpectation.params) {
			mmGetListLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListLog.defaultExpectation.params)
		}
	}

	return mmGetListLog
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.GetListLog
func (mmGetListLog *mChatServerRepositoryMockGetListLog) Inspect(f func(ctx context.Context, pageNumber uint64, pageSize uint64)) *mChatServerRepositoryMockGetListLog {
	if mmGetListLog.mock.inspectFuncGetListLog != nil {
		mmGetListLog.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.GetListLog")
	}

	mmGetListLog.mock.inspectFuncGetListLog = f

	return mmGetListLog
}

// Return sets up results that will be returned by ChatServerRepository.GetListLog
func (mmGetListLog *mChatServerRepositoryMockGetListLog) Return(lpa1 []*model.Log, err error) *ChatServerRepositoryMock {
	if mmGetListLog.mock.funcGetListLog != nil {
		mmGetListLog.mock.t.Fatalf("ChatServerRepositoryMock.GetListLog mock is already set by Set")
	}

	if mmGetListLog.defaultExpectation == nil {
		mmGetListLog.defaultExpectation = &ChatServerRepositoryMockGetListLogExpectation{mock: mmGetListLog.mock}
	}
	mmGetListLog.defaultExpectation.results = &ChatServerRepositoryMockGetListLogResults{lpa1, err}
	return mmGetListLog.mock
}

// Set uses given function f to mock the ChatServerRepository.GetListLog method
func (mmGetListLog *mChatServerRepositoryMockGetListLog) Set(f func(ctx context.Context, pageNumber uint64, pageSize uint64) (lpa1 []*model.Log, err error)) *ChatServerRepositoryMock {
	if mmGetListLog.defaultExpectation != nil {
		mmGetListLog.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.GetListLog method")
	}

	if len(mmGetListLog.expectations) > 0 {
		mmGetListLog.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.GetListLog method")
	}

	mmGetListLog.mock.funcGetListLog = f
	return mmGetListLog.mock
}

// When sets expectation for the ChatServerRepository.GetListLog which will trigger the result defined by the following
// Then helper
func (mmGetListLog *mChatServerRepositoryMockGetListLog) When(ctx context.Context, pageNumber uint64, pageSize uint64) *ChatServerRepositoryMockGetListLogExpectation {
	if mmGetListLog.mock.funcGetListLog != nil {
		mmGetListLog.mock.t.Fatalf("ChatServerRepositoryMock.GetListLog mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockGetListLogExpectation{
		mock:   mmGetListLog.mock,
		params: &ChatServerRepositoryMockGetListLogParams{ctx, pageNumber, pageSize},
	}
	mmGetListLog.expectations = append(mmGetListLog.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.GetListLog return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockGetListLogExpectation) Then(lpa1 []*model.Log, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockGetListLogResults{lpa1, err}
	return e.mock
}

// GetListLog implements repository.ChatServerRepository
func (mmGetListLog *ChatServerRepositoryMock) GetListLog(ctx context.Context, pageNumber uint64, pageSize uint64) (lpa1 []*model.Log, err error) {
	mm_atomic.AddUint64(&mmGetListLog.beforeGetListLogCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListLog.afterGetListLogCounter, 1)

	if mmGetListLog.inspectFuncGetListLog != nil {
		mmGetListLog.inspectFuncGetListLog(ctx, pageNumber, pageSize)
	}

	mm_params := ChatServerRepositoryMockGetListLogParams{ctx, pageNumber, pageSize}

	// Record call args
	mmGetListLog.GetListLogMock.mutex.Lock()
	mmGetListLog.GetListLogMock.callArgs = append(mmGetListLog.GetListLogMock.callArgs, &mm_params)
	mmGetListLog.GetListLogMock.mutex.Unlock()

	for _, e := range mmGetListLog.GetListLogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lpa1, e.results.err
		}
	}

	if mmGetListLog.GetListLogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListLog.GetListLogMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListLog.GetListLogMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockGetListLogParams{ctx, pageNumber, pageSize}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListLog.t.Errorf("ChatServerRepositoryMock.GetListLog got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListLog.GetListLogMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListLog.t.Fatal("No results are set for the ChatServerRepositoryMock.GetListLog")
		}
		return (*mm_results).lpa1, (*mm_results).err
	}
	if mmGetListLog.funcGetListLog != nil {
		return mmGetListLog.funcGetListLog(ctx, pageNumber, pageSize)
	}
	mmGetListLog.t.Fatalf("Unexpected call to ChatServerRepositoryMock.GetListLog. %v %v %v", ctx, pageNumber, pageSize)
	return
}

// GetListLogAfterCounter returns a count of finished ChatServerRepositoryMock.GetListLog invocations
func (mmGetListLog *ChatServerRepositoryMock) GetListLogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListLog.afterGetListLogCounter)
}

// GetListLogBeforeCounter returns a count of ChatServerRepositoryMock.GetListLog invocations
func (mmGetListLog *ChatServerRepositoryMock) GetListLogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListLog.beforeGetListLogCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.GetListLog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListLog *mChatServerRepositoryMockGetListLog) Calls() []*ChatServerRepositoryMockGetListLogParams {
	mmGetListLog.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockGetListLogParams, len(mmGetListLog.callArgs))
	copy(argCopy, mmGetListLog.callArgs)

	mmGetListLog.mutex.RUnlock()

	return argCopy
}

// MinimockGetListLogDone returns true if the count of the GetListLog invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockGetListLogDone() bool {
	for _, e := range m.GetListLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListLogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListLogCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListLog != nil && mm_atomic.LoadUint64(&m.afterGetListLogCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListLogInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockGetListLogInspect() {
	for _, e := range m.GetListLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.GetListLog with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListLogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListLogCounter) < 1 {
		if m.GetListLogMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.GetListLog")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.GetListLog with params: %#v", *m.GetListLogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListLog != nil && mm_atomic.LoadUint64(&m.afterGetListLogCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.GetListLog")
	}
}

type mChatServerRepositoryMockGetOfCreateUsers struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockGetOfCreateUsersExpectation
	expectations       []*ChatServerRepositoryMockGetOfCreateUsersExpectation

	callArgs []*ChatServerRepositoryMockGetOfCreateUsersParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockGetOfCreateUsersExpectation specifies expectation struct of the ChatServerRepository.GetOfCreateUsers
type ChatServerRepositoryMockGetOfCreateUsersExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockGetOfCreateUsersParams
	results *ChatServerRepositoryMockGetOfCreateUsersResults
	Counter uint64
}

// ChatServerRepositoryMockGetOfCreateUsersParams contains parameters of the ChatServerRepository.GetOfCreateUsers
type ChatServerRepositoryMockGetOfCreateUsersParams struct {
	ctx   context.Context
	users []*model.User
}

// ChatServerRepositoryMockGetOfCreateUsersResults contains results of the ChatServerRepository.GetOfCreateUsers
type ChatServerRepositoryMockGetOfCreateUsersResults struct {
	ia1 []int64
	qa1 []db.Query
	err error
}

// Expect sets up expected params for ChatServerRepository.GetOfCreateUsers
func (mmGetOfCreateUsers *mChatServerRepositoryMockGetOfCreateUsers) Expect(ctx context.Context, users []*model.User) *mChatServerRepositoryMockGetOfCreateUsers {
	if mmGetOfCreateUsers.mock.funcGetOfCreateUsers != nil {
		mmGetOfCreateUsers.mock.t.Fatalf("ChatServerRepositoryMock.GetOfCreateUsers mock is already set by Set")
	}

	if mmGetOfCreateUsers.defaultExpectation == nil {
		mmGetOfCreateUsers.defaultExpectation = &ChatServerRepositoryMockGetOfCreateUsersExpectation{}
	}

	mmGetOfCreateUsers.defaultExpectation.params = &ChatServerRepositoryMockGetOfCreateUsersParams{ctx, users}
	for _, e := range mmGetOfCreateUsers.expectations {
		if minimock.Equal(e.params, mmGetOfCreateUsers.defaultExpectation.params) {
			mmGetOfCreateUsers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOfCreateUsers.defaultExpectation.params)
		}
	}

	return mmGetOfCreateUsers
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.GetOfCreateUsers
func (mmGetOfCreateUsers *mChatServerRepositoryMockGetOfCreateUsers) Inspect(f func(ctx context.Context, users []*model.User)) *mChatServerRepositoryMockGetOfCreateUsers {
	if mmGetOfCreateUsers.mock.inspectFuncGetOfCreateUsers != nil {
		mmGetOfCreateUsers.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.GetOfCreateUsers")
	}

	mmGetOfCreateUsers.mock.inspectFuncGetOfCreateUsers = f

	return mmGetOfCreateUsers
}

// Return sets up results that will be returned by ChatServerRepository.GetOfCreateUsers
func (mmGetOfCreateUsers *mChatServerRepositoryMockGetOfCreateUsers) Return(ia1 []int64, qa1 []db.Query, err error) *ChatServerRepositoryMock {
	if mmGetOfCreateUsers.mock.funcGetOfCreateUsers != nil {
		mmGetOfCreateUsers.mock.t.Fatalf("ChatServerRepositoryMock.GetOfCreateUsers mock is already set by Set")
	}

	if mmGetOfCreateUsers.defaultExpectation == nil {
		mmGetOfCreateUsers.defaultExpectation = &ChatServerRepositoryMockGetOfCreateUsersExpectation{mock: mmGetOfCreateUsers.mock}
	}
	mmGetOfCreateUsers.defaultExpectation.results = &ChatServerRepositoryMockGetOfCreateUsersResults{ia1, qa1, err}
	return mmGetOfCreateUsers.mock
}

// Set uses given function f to mock the ChatServerRepository.GetOfCreateUsers method
func (mmGetOfCreateUsers *mChatServerRepositoryMockGetOfCreateUsers) Set(f func(ctx context.Context, users []*model.User) (ia1 []int64, qa1 []db.Query, err error)) *ChatServerRepositoryMock {
	if mmGetOfCreateUsers.defaultExpectation != nil {
		mmGetOfCreateUsers.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.GetOfCreateUsers method")
	}

	if len(mmGetOfCreateUsers.expectations) > 0 {
		mmGetOfCreateUsers.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.GetOfCreateUsers method")
	}

	mmGetOfCreateUsers.mock.funcGetOfCreateUsers = f
	return mmGetOfCreateUsers.mock
}

// When sets expectation for the ChatServerRepository.GetOfCreateUsers which will trigger the result defined by the following
// Then helper
func (mmGetOfCreateUsers *mChatServerRepositoryMockGetOfCreateUsers) When(ctx context.Context, users []*model.User) *ChatServerRepositoryMockGetOfCreateUsersExpectation {
	if mmGetOfCreateUsers.mock.funcGetOfCreateUsers != nil {
		mmGetOfCreateUsers.mock.t.Fatalf("ChatServerRepositoryMock.GetOfCreateUsers mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockGetOfCreateUsersExpectation{
		mock:   mmGetOfCreateUsers.mock,
		params: &ChatServerRepositoryMockGetOfCreateUsersParams{ctx, users},
	}
	mmGetOfCreateUsers.expectations = append(mmGetOfCreateUsers.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.GetOfCreateUsers return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockGetOfCreateUsersExpectation) Then(ia1 []int64, qa1 []db.Query, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockGetOfCreateUsersResults{ia1, qa1, err}
	return e.mock
}

// GetOfCreateUsers implements repository.ChatServerRepository
func (mmGetOfCreateUsers *ChatServerRepositoryMock) GetOfCreateUsers(ctx context.Context, users []*model.User) (ia1 []int64, qa1 []db.Query, err error) {
	mm_atomic.AddUint64(&mmGetOfCreateUsers.beforeGetOfCreateUsersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOfCreateUsers.afterGetOfCreateUsersCounter, 1)

	if mmGetOfCreateUsers.inspectFuncGetOfCreateUsers != nil {
		mmGetOfCreateUsers.inspectFuncGetOfCreateUsers(ctx, users)
	}

	mm_params := ChatServerRepositoryMockGetOfCreateUsersParams{ctx, users}

	// Record call args
	mmGetOfCreateUsers.GetOfCreateUsersMock.mutex.Lock()
	mmGetOfCreateUsers.GetOfCreateUsersMock.callArgs = append(mmGetOfCreateUsers.GetOfCreateUsersMock.callArgs, &mm_params)
	mmGetOfCreateUsers.GetOfCreateUsersMock.mutex.Unlock()

	for _, e := range mmGetOfCreateUsers.GetOfCreateUsersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.qa1, e.results.err
		}
	}

	if mmGetOfCreateUsers.GetOfCreateUsersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOfCreateUsers.GetOfCreateUsersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOfCreateUsers.GetOfCreateUsersMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockGetOfCreateUsersParams{ctx, users}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOfCreateUsers.t.Errorf("ChatServerRepositoryMock.GetOfCreateUsers got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOfCreateUsers.GetOfCreateUsersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOfCreateUsers.t.Fatal("No results are set for the ChatServerRepositoryMock.GetOfCreateUsers")
		}
		return (*mm_results).ia1, (*mm_results).qa1, (*mm_results).err
	}
	if mmGetOfCreateUsers.funcGetOfCreateUsers != nil {
		return mmGetOfCreateUsers.funcGetOfCreateUsers(ctx, users)
	}
	mmGetOfCreateUsers.t.Fatalf("Unexpected call to ChatServerRepositoryMock.GetOfCreateUsers. %v %v", ctx, users)
	return
}

// GetOfCreateUsersAfterCounter returns a count of finished ChatServerRepositoryMock.GetOfCreateUsers invocations
func (mmGetOfCreateUsers *ChatServerRepositoryMock) GetOfCreateUsersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOfCreateUsers.afterGetOfCreateUsersCounter)
}

// GetOfCreateUsersBeforeCounter returns a count of ChatServerRepositoryMock.GetOfCreateUsers invocations
func (mmGetOfCreateUsers *ChatServerRepositoryMock) GetOfCreateUsersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOfCreateUsers.beforeGetOfCreateUsersCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.GetOfCreateUsers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOfCreateUsers *mChatServerRepositoryMockGetOfCreateUsers) Calls() []*ChatServerRepositoryMockGetOfCreateUsersParams {
	mmGetOfCreateUsers.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockGetOfCreateUsersParams, len(mmGetOfCreateUsers.callArgs))
	copy(argCopy, mmGetOfCreateUsers.callArgs)

	mmGetOfCreateUsers.mutex.RUnlock()

	return argCopy
}

// MinimockGetOfCreateUsersDone returns true if the count of the GetOfCreateUsers invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockGetOfCreateUsersDone() bool {
	for _, e := range m.GetOfCreateUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOfCreateUsersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOfCreateUsersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOfCreateUsers != nil && mm_atomic.LoadUint64(&m.afterGetOfCreateUsersCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOfCreateUsersInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockGetOfCreateUsersInspect() {
	for _, e := range m.GetOfCreateUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.GetOfCreateUsers with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOfCreateUsersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOfCreateUsersCounter) < 1 {
		if m.GetOfCreateUsersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.GetOfCreateUsers")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.GetOfCreateUsers with params: %#v", *m.GetOfCreateUsersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOfCreateUsers != nil && mm_atomic.LoadUint64(&m.afterGetOfCreateUsersCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.GetOfCreateUsers")
	}
}

type mChatServerRepositoryMockGetUserIDByName struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockGetUserIDByNameExpectation
	expectations       []*ChatServerRepositoryMockGetUserIDByNameExpectation

	callArgs []*ChatServerRepositoryMockGetUserIDByNameParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockGetUserIDByNameExpectation specifies expectation struct of the ChatServerRepository.GetUserIDByName
type ChatServerRepositoryMockGetUserIDByNameExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockGetUserIDByNameParams
	results *ChatServerRepositoryMockGetUserIDByNameResults
	Counter uint64
}

// ChatServerRepositoryMockGetUserIDByNameParams contains parameters of the ChatServerRepository.GetUserIDByName
type ChatServerRepositoryMockGetUserIDByNameParams struct {
	ctx  context.Context
	name string
}

// ChatServerRepositoryMockGetUserIDByNameResults contains results of the ChatServerRepository.GetUserIDByName
type ChatServerRepositoryMockGetUserIDByNameResults struct {
	i1  int64
	q1  db.Query
	err error
}

// Expect sets up expected params for ChatServerRepository.GetUserIDByName
func (mmGetUserIDByName *mChatServerRepositoryMockGetUserIDByName) Expect(ctx context.Context, name string) *mChatServerRepositoryMockGetUserIDByName {
	if mmGetUserIDByName.mock.funcGetUserIDByName != nil {
		mmGetUserIDByName.mock.t.Fatalf("ChatServerRepositoryMock.GetUserIDByName mock is already set by Set")
	}

	if mmGetUserIDByName.defaultExpectation == nil {
		mmGetUserIDByName.defaultExpectation = &ChatServerRepositoryMockGetUserIDByNameExpectation{}
	}

	mmGetUserIDByName.defaultExpectation.params = &ChatServerRepositoryMockGetUserIDByNameParams{ctx, name}
	for _, e := range mmGetUserIDByName.expectations {
		if minimock.Equal(e.params, mmGetUserIDByName.defaultExpectation.params) {
			mmGetUserIDByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserIDByName.defaultExpectation.params)
		}
	}

	return mmGetUserIDByName
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.GetUserIDByName
func (mmGetUserIDByName *mChatServerRepositoryMockGetUserIDByName) Inspect(f func(ctx context.Context, name string)) *mChatServerRepositoryMockGetUserIDByName {
	if mmGetUserIDByName.mock.inspectFuncGetUserIDByName != nil {
		mmGetUserIDByName.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.GetUserIDByName")
	}

	mmGetUserIDByName.mock.inspectFuncGetUserIDByName = f

	return mmGetUserIDByName
}

// Return sets up results that will be returned by ChatServerRepository.GetUserIDByName
func (mmGetUserIDByName *mChatServerRepositoryMockGetUserIDByName) Return(i1 int64, q1 db.Query, err error) *ChatServerRepositoryMock {
	if mmGetUserIDByName.mock.funcGetUserIDByName != nil {
		mmGetUserIDByName.mock.t.Fatalf("ChatServerRepositoryMock.GetUserIDByName mock is already set by Set")
	}

	if mmGetUserIDByName.defaultExpectation == nil {
		mmGetUserIDByName.defaultExpectation = &ChatServerRepositoryMockGetUserIDByNameExpectation{mock: mmGetUserIDByName.mock}
	}
	mmGetUserIDByName.defaultExpectation.results = &ChatServerRepositoryMockGetUserIDByNameResults{i1, q1, err}
	return mmGetUserIDByName.mock
}

// Set uses given function f to mock the ChatServerRepository.GetUserIDByName method
func (mmGetUserIDByName *mChatServerRepositoryMockGetUserIDByName) Set(f func(ctx context.Context, name string) (i1 int64, q1 db.Query, err error)) *ChatServerRepositoryMock {
	if mmGetUserIDByName.defaultExpectation != nil {
		mmGetUserIDByName.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.GetUserIDByName method")
	}

	if len(mmGetUserIDByName.expectations) > 0 {
		mmGetUserIDByName.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.GetUserIDByName method")
	}

	mmGetUserIDByName.mock.funcGetUserIDByName = f
	return mmGetUserIDByName.mock
}

// When sets expectation for the ChatServerRepository.GetUserIDByName which will trigger the result defined by the following
// Then helper
func (mmGetUserIDByName *mChatServerRepositoryMockGetUserIDByName) When(ctx context.Context, name string) *ChatServerRepositoryMockGetUserIDByNameExpectation {
	if mmGetUserIDByName.mock.funcGetUserIDByName != nil {
		mmGetUserIDByName.mock.t.Fatalf("ChatServerRepositoryMock.GetUserIDByName mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockGetUserIDByNameExpectation{
		mock:   mmGetUserIDByName.mock,
		params: &ChatServerRepositoryMockGetUserIDByNameParams{ctx, name},
	}
	mmGetUserIDByName.expectations = append(mmGetUserIDByName.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.GetUserIDByName return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockGetUserIDByNameExpectation) Then(i1 int64, q1 db.Query, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockGetUserIDByNameResults{i1, q1, err}
	return e.mock
}

// GetUserIDByName implements repository.ChatServerRepository
func (mmGetUserIDByName *ChatServerRepositoryMock) GetUserIDByName(ctx context.Context, name string) (i1 int64, q1 db.Query, err error) {
	mm_atomic.AddUint64(&mmGetUserIDByName.beforeGetUserIDByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserIDByName.afterGetUserIDByNameCounter, 1)

	if mmGetUserIDByName.inspectFuncGetUserIDByName != nil {
		mmGetUserIDByName.inspectFuncGetUserIDByName(ctx, name)
	}

	mm_params := ChatServerRepositoryMockGetUserIDByNameParams{ctx, name}

	// Record call args
	mmGetUserIDByName.GetUserIDByNameMock.mutex.Lock()
	mmGetUserIDByName.GetUserIDByNameMock.callArgs = append(mmGetUserIDByName.GetUserIDByNameMock.callArgs, &mm_params)
	mmGetUserIDByName.GetUserIDByNameMock.mutex.Unlock()

	for _, e := range mmGetUserIDByName.GetUserIDByNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.q1, e.results.err
		}
	}

	if mmGetUserIDByName.GetUserIDByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserIDByName.GetUserIDByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserIDByName.GetUserIDByNameMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockGetUserIDByNameParams{ctx, name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserIDByName.t.Errorf("ChatServerRepositoryMock.GetUserIDByName got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserIDByName.GetUserIDByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserIDByName.t.Fatal("No results are set for the ChatServerRepositoryMock.GetUserIDByName")
		}
		return (*mm_results).i1, (*mm_results).q1, (*mm_results).err
	}
	if mmGetUserIDByName.funcGetUserIDByName != nil {
		return mmGetUserIDByName.funcGetUserIDByName(ctx, name)
	}
	mmGetUserIDByName.t.Fatalf("Unexpected call to ChatServerRepositoryMock.GetUserIDByName. %v %v", ctx, name)
	return
}

// GetUserIDByNameAfterCounter returns a count of finished ChatServerRepositoryMock.GetUserIDByName invocations
func (mmGetUserIDByName *ChatServerRepositoryMock) GetUserIDByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserIDByName.afterGetUserIDByNameCounter)
}

// GetUserIDByNameBeforeCounter returns a count of ChatServerRepositoryMock.GetUserIDByName invocations
func (mmGetUserIDByName *ChatServerRepositoryMock) GetUserIDByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserIDByName.beforeGetUserIDByNameCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.GetUserIDByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserIDByName *mChatServerRepositoryMockGetUserIDByName) Calls() []*ChatServerRepositoryMockGetUserIDByNameParams {
	mmGetUserIDByName.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockGetUserIDByNameParams, len(mmGetUserIDByName.callArgs))
	copy(argCopy, mmGetUserIDByName.callArgs)

	mmGetUserIDByName.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserIDByNameDone returns true if the count of the GetUserIDByName invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockGetUserIDByNameDone() bool {
	for _, e := range m.GetUserIDByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserIDByNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserIDByNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserIDByName != nil && mm_atomic.LoadUint64(&m.afterGetUserIDByNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserIDByNameInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockGetUserIDByNameInspect() {
	for _, e := range m.GetUserIDByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.GetUserIDByName with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserIDByNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserIDByNameCounter) < 1 {
		if m.GetUserIDByNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.GetUserIDByName")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.GetUserIDByName with params: %#v", *m.GetUserIDByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserIDByName != nil && mm_atomic.LoadUint64(&m.afterGetUserIDByNameCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.GetUserIDByName")
	}
}

type mChatServerRepositoryMockSendMessage struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockSendMessageExpectation
	expectations       []*ChatServerRepositoryMockSendMessageExpectation

	callArgs []*ChatServerRepositoryMockSendMessageParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockSendMessageExpectation specifies expectation struct of the ChatServerRepository.SendMessage
type ChatServerRepositoryMockSendMessageExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockSendMessageParams
	results *ChatServerRepositoryMockSendMessageResults
	Counter uint64
}

// ChatServerRepositoryMockSendMessageParams contains parameters of the ChatServerRepository.SendMessage
type ChatServerRepositoryMockSendMessageParams struct {
	ctx     context.Context
	message *model.Message
	userID  int64
}

// ChatServerRepositoryMockSendMessageResults contains results of the ChatServerRepository.SendMessage
type ChatServerRepositoryMockSendMessageResults struct {
	q1  db.Query
	err error
}

// Expect sets up expected params for ChatServerRepository.SendMessage
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Expect(ctx context.Context, message *model.Message, userID int64) *mChatServerRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServerRepositoryMockSendMessageExpectation{}
	}

	mmSendMessage.defaultExpectation.params = &ChatServerRepositoryMockSendMessageParams{ctx, message, userID}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.SendMessage
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Inspect(f func(ctx context.Context, message *model.Message, userID int64)) *mChatServerRepositoryMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatServerRepository.SendMessage
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Return(q1 db.Query, err error) *ChatServerRepositoryMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServerRepositoryMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatServerRepositoryMockSendMessageResults{q1, err}
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatServerRepository.SendMessage method
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Set(f func(ctx context.Context, message *model.Message, userID int64) (q1 db.Query, err error)) *ChatServerRepositoryMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the ChatServerRepository.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatServerRepositoryMockSendMessage) When(ctx context.Context, message *model.Message, userID int64) *ChatServerRepositoryMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerRepositoryMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &ChatServerRepositoryMockSendMessageParams{ctx, message, userID},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockSendMessageExpectation) Then(q1 db.Query, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockSendMessageResults{q1, err}
	return e.mock
}

// SendMessage implements repository.ChatServerRepository
func (mmSendMessage *ChatServerRepositoryMock) SendMessage(ctx context.Context, message *model.Message, userID int64) (q1 db.Query, err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, message, userID)
	}

	mm_params := ChatServerRepositoryMockSendMessageParams{ctx, message, userID}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.q1, e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockSendMessageParams{ctx, message, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatServerRepositoryMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatServerRepositoryMock.SendMessage")
		}
		return (*mm_results).q1, (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, message, userID)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatServerRepositoryMock.SendMessage. %v %v %v", ctx, message, userID)
	return
}

// SendMessageAfterCounter returns a count of finished ChatServerRepositoryMock.SendMessage invocations
func (mmSendMessage *ChatServerRepositoryMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatServerRepositoryMock.SendMessage invocations
func (mmSendMessage *ChatServerRepositoryMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Calls() []*ChatServerRepositoryMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockSendMessageDone() bool {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.SendMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.SendMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServerRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBindUserToChatInspect()

			m.MinimockChatExistsInspect()

			m.MinimockCreateChatInspect()

			m.MinimockCreateLogInspect()

			m.MinimockDeleteBindUserFromChatInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockDeleteMessageFromChatInspect()

			m.MinimockGetListLogInspect()

			m.MinimockGetOfCreateUsersInspect()

			m.MinimockGetUserIDByNameInspect()

			m.MinimockSendMessageInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServerRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServerRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBindUserToChatDone() &&
		m.MinimockChatExistsDone() &&
		m.MinimockCreateChatDone() &&
		m.MinimockCreateLogDone() &&
		m.MinimockDeleteBindUserFromChatDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockDeleteMessageFromChatDone() &&
		m.MinimockGetListLogDone() &&
		m.MinimockGetOfCreateUsersDone() &&
		m.MinimockGetUserIDByNameDone() &&
		m.MinimockSendMessageDone()
}
