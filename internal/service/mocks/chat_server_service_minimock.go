// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/semho/chat-microservices/chat-server/internal/service.ChatServerService -o chat_server_service_minimock.go -n ChatServerServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/semho/chat-microservices/chat-server/internal/model"
)

// ChatServerServiceMock implements service.ChatServerService
type ChatServerServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateChat          func(ctx context.Context, users []*model.User) (i1 int64, err error)
	inspectFuncCreateChat   func(ctx context.Context, users []*model.User)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatServerServiceMockCreateChat

	funcDeleteChat          func(ctx context.Context, chatId int64) (err error)
	inspectFuncDeleteChat   func(ctx context.Context, chatId int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatServerServiceMockDeleteChat

	funcGetListLogs          func(ctx context.Context, pageNumber uint64, pageSize uint64) (lpa1 []*model.Log, err error)
	inspectFuncGetListLogs   func(ctx context.Context, pageNumber uint64, pageSize uint64)
	afterGetListLogsCounter  uint64
	beforeGetListLogsCounter uint64
	GetListLogsMock          mChatServerServiceMockGetListLogs

	funcSendMessage          func(ctx context.Context, message *model.Message) (err error)
	inspectFuncSendMessage   func(ctx context.Context, message *model.Message)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatServerServiceMockSendMessage
}

// NewChatServerServiceMock returns a mock for service.ChatServerService
func NewChatServerServiceMock(t minimock.Tester) *ChatServerServiceMock {
	m := &ChatServerServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateChatMock = mChatServerServiceMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatServerServiceMockCreateChatParams{}

	m.DeleteChatMock = mChatServerServiceMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatServerServiceMockDeleteChatParams{}

	m.GetListLogsMock = mChatServerServiceMockGetListLogs{mock: m}
	m.GetListLogsMock.callArgs = []*ChatServerServiceMockGetListLogsParams{}

	m.SendMessageMock = mChatServerServiceMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatServerServiceMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServerServiceMockCreateChat struct {
	mock               *ChatServerServiceMock
	defaultExpectation *ChatServerServiceMockCreateChatExpectation
	expectations       []*ChatServerServiceMockCreateChatExpectation

	callArgs []*ChatServerServiceMockCreateChatParams
	mutex    sync.RWMutex
}

// ChatServerServiceMockCreateChatExpectation specifies expectation struct of the ChatServerService.CreateChat
type ChatServerServiceMockCreateChatExpectation struct {
	mock    *ChatServerServiceMock
	params  *ChatServerServiceMockCreateChatParams
	results *ChatServerServiceMockCreateChatResults
	Counter uint64
}

// ChatServerServiceMockCreateChatParams contains parameters of the ChatServerService.CreateChat
type ChatServerServiceMockCreateChatParams struct {
	ctx   context.Context
	users []*model.User
}

// ChatServerServiceMockCreateChatResults contains results of the ChatServerService.CreateChat
type ChatServerServiceMockCreateChatResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for ChatServerService.CreateChat
func (mmCreateChat *mChatServerServiceMockCreateChat) Expect(ctx context.Context, users []*model.User) *mChatServerServiceMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServerServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServerServiceMockCreateChatExpectation{}
	}

	mmCreateChat.defaultExpectation.params = &ChatServerServiceMockCreateChatParams{ctx, users}
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatServerService.CreateChat
func (mmCreateChat *mChatServerServiceMockCreateChat) Inspect(f func(ctx context.Context, users []*model.User)) *mChatServerServiceMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatServerServiceMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatServerService.CreateChat
func (mmCreateChat *mChatServerServiceMockCreateChat) Return(i1 int64, err error) *ChatServerServiceMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServerServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServerServiceMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatServerServiceMockCreateChatResults{i1, err}
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatServerService.CreateChat method
func (mmCreateChat *mChatServerServiceMockCreateChat) Set(f func(ctx context.Context, users []*model.User) (i1 int64, err error)) *ChatServerServiceMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatServerService.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatServerService.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	return mmCreateChat.mock
}

// When sets expectation for the ChatServerService.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatServerServiceMockCreateChat) When(ctx context.Context, users []*model.User) *ChatServerServiceMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServerServiceMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatServerServiceMockCreateChatExpectation{
		mock:   mmCreateChat.mock,
		params: &ChatServerServiceMockCreateChatParams{ctx, users},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatServerService.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatServerServiceMockCreateChatExpectation) Then(i1 int64, err error) *ChatServerServiceMock {
	e.results = &ChatServerServiceMockCreateChatResults{i1, err}
	return e.mock
}

// CreateChat implements service.ChatServerService
func (mmCreateChat *ChatServerServiceMock) CreateChat(ctx context.Context, users []*model.User) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, users)
	}

	mm_params := ChatServerServiceMockCreateChatParams{ctx, users}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_got := ChatServerServiceMockCreateChatParams{ctx, users}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatServerServiceMock.CreateChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatServerServiceMock.CreateChat")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, users)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatServerServiceMock.CreateChat. %v %v", ctx, users)
	return
}

// CreateChatAfterCounter returns a count of finished ChatServerServiceMock.CreateChat invocations
func (mmCreateChat *ChatServerServiceMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatServerServiceMock.CreateChat invocations
func (mmCreateChat *ChatServerServiceMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServerServiceMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatServerServiceMockCreateChat) Calls() []*ChatServerServiceMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatServerServiceMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatServerServiceMock) MinimockCreateChatDone() bool {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatServerServiceMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerServiceMock.CreateChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerServiceMock.CreateChat")
		} else {
			m.t.Errorf("Expected call to ChatServerServiceMock.CreateChat with params: %#v", *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		m.t.Error("Expected call to ChatServerServiceMock.CreateChat")
	}
}

type mChatServerServiceMockDeleteChat struct {
	mock               *ChatServerServiceMock
	defaultExpectation *ChatServerServiceMockDeleteChatExpectation
	expectations       []*ChatServerServiceMockDeleteChatExpectation

	callArgs []*ChatServerServiceMockDeleteChatParams
	mutex    sync.RWMutex
}

// ChatServerServiceMockDeleteChatExpectation specifies expectation struct of the ChatServerService.DeleteChat
type ChatServerServiceMockDeleteChatExpectation struct {
	mock    *ChatServerServiceMock
	params  *ChatServerServiceMockDeleteChatParams
	results *ChatServerServiceMockDeleteChatResults
	Counter uint64
}

// ChatServerServiceMockDeleteChatParams contains parameters of the ChatServerService.DeleteChat
type ChatServerServiceMockDeleteChatParams struct {
	ctx    context.Context
	chatId int64
}

// ChatServerServiceMockDeleteChatResults contains results of the ChatServerService.DeleteChat
type ChatServerServiceMockDeleteChatResults struct {
	err error
}

// Expect sets up expected params for ChatServerService.DeleteChat
func (mmDeleteChat *mChatServerServiceMockDeleteChat) Expect(ctx context.Context, chatId int64) *mChatServerServiceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServerServiceMockDeleteChatExpectation{}
	}

	mmDeleteChat.defaultExpectation.params = &ChatServerServiceMockDeleteChatParams{ctx, chatId}
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatServerService.DeleteChat
func (mmDeleteChat *mChatServerServiceMockDeleteChat) Inspect(f func(ctx context.Context, chatId int64)) *mChatServerServiceMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatServerServiceMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatServerService.DeleteChat
func (mmDeleteChat *mChatServerServiceMockDeleteChat) Return(err error) *ChatServerServiceMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServerServiceMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatServerServiceMockDeleteChatResults{err}
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatServerService.DeleteChat method
func (mmDeleteChat *mChatServerServiceMockDeleteChat) Set(f func(ctx context.Context, chatId int64) (err error)) *ChatServerServiceMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatServerService.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatServerService.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	return mmDeleteChat.mock
}

// When sets expectation for the ChatServerService.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatServerServiceMockDeleteChat) When(ctx context.Context, chatId int64) *ChatServerServiceMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerServiceMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatServerServiceMockDeleteChatExpectation{
		mock:   mmDeleteChat.mock,
		params: &ChatServerServiceMockDeleteChatParams{ctx, chatId},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatServerService.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatServerServiceMockDeleteChatExpectation) Then(err error) *ChatServerServiceMock {
	e.results = &ChatServerServiceMockDeleteChatResults{err}
	return e.mock
}

// DeleteChat implements service.ChatServerService
func (mmDeleteChat *ChatServerServiceMock) DeleteChat(ctx context.Context, chatId int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, chatId)
	}

	mm_params := ChatServerServiceMockDeleteChatParams{ctx, chatId}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_got := ChatServerServiceMockDeleteChatParams{ctx, chatId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatServerServiceMock.DeleteChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatServerServiceMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, chatId)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatServerServiceMock.DeleteChat. %v %v", ctx, chatId)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatServerServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServerServiceMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatServerServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServerServiceMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServerServiceMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatServerServiceMockDeleteChat) Calls() []*ChatServerServiceMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatServerServiceMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatServerServiceMock) MinimockDeleteChatDone() bool {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatServerServiceMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerServiceMock.DeleteChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerServiceMock.DeleteChat")
		} else {
			m.t.Errorf("Expected call to ChatServerServiceMock.DeleteChat with params: %#v", *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && mm_atomic.LoadUint64(&m.afterDeleteChatCounter) < 1 {
		m.t.Error("Expected call to ChatServerServiceMock.DeleteChat")
	}
}

type mChatServerServiceMockGetListLogs struct {
	mock               *ChatServerServiceMock
	defaultExpectation *ChatServerServiceMockGetListLogsExpectation
	expectations       []*ChatServerServiceMockGetListLogsExpectation

	callArgs []*ChatServerServiceMockGetListLogsParams
	mutex    sync.RWMutex
}

// ChatServerServiceMockGetListLogsExpectation specifies expectation struct of the ChatServerService.GetListLogs
type ChatServerServiceMockGetListLogsExpectation struct {
	mock    *ChatServerServiceMock
	params  *ChatServerServiceMockGetListLogsParams
	results *ChatServerServiceMockGetListLogsResults
	Counter uint64
}

// ChatServerServiceMockGetListLogsParams contains parameters of the ChatServerService.GetListLogs
type ChatServerServiceMockGetListLogsParams struct {
	ctx        context.Context
	pageNumber uint64
	pageSize   uint64
}

// ChatServerServiceMockGetListLogsResults contains results of the ChatServerService.GetListLogs
type ChatServerServiceMockGetListLogsResults struct {
	lpa1 []*model.Log
	err  error
}

// Expect sets up expected params for ChatServerService.GetListLogs
func (mmGetListLogs *mChatServerServiceMockGetListLogs) Expect(ctx context.Context, pageNumber uint64, pageSize uint64) *mChatServerServiceMockGetListLogs {
	if mmGetListLogs.mock.funcGetListLogs != nil {
		mmGetListLogs.mock.t.Fatalf("ChatServerServiceMock.GetListLogs mock is already set by Set")
	}

	if mmGetListLogs.defaultExpectation == nil {
		mmGetListLogs.defaultExpectation = &ChatServerServiceMockGetListLogsExpectation{}
	}

	mmGetListLogs.defaultExpectation.params = &ChatServerServiceMockGetListLogsParams{ctx, pageNumber, pageSize}
	for _, e := range mmGetListLogs.expectations {
		if minimock.Equal(e.params, mmGetListLogs.defaultExpectation.params) {
			mmGetListLogs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListLogs.defaultExpectation.params)
		}
	}

	return mmGetListLogs
}

// Inspect accepts an inspector function that has same arguments as the ChatServerService.GetListLogs
func (mmGetListLogs *mChatServerServiceMockGetListLogs) Inspect(f func(ctx context.Context, pageNumber uint64, pageSize uint64)) *mChatServerServiceMockGetListLogs {
	if mmGetListLogs.mock.inspectFuncGetListLogs != nil {
		mmGetListLogs.mock.t.Fatalf("Inspect function is already set for ChatServerServiceMock.GetListLogs")
	}

	mmGetListLogs.mock.inspectFuncGetListLogs = f

	return mmGetListLogs
}

// Return sets up results that will be returned by ChatServerService.GetListLogs
func (mmGetListLogs *mChatServerServiceMockGetListLogs) Return(lpa1 []*model.Log, err error) *ChatServerServiceMock {
	if mmGetListLogs.mock.funcGetListLogs != nil {
		mmGetListLogs.mock.t.Fatalf("ChatServerServiceMock.GetListLogs mock is already set by Set")
	}

	if mmGetListLogs.defaultExpectation == nil {
		mmGetListLogs.defaultExpectation = &ChatServerServiceMockGetListLogsExpectation{mock: mmGetListLogs.mock}
	}
	mmGetListLogs.defaultExpectation.results = &ChatServerServiceMockGetListLogsResults{lpa1, err}
	return mmGetListLogs.mock
}

// Set uses given function f to mock the ChatServerService.GetListLogs method
func (mmGetListLogs *mChatServerServiceMockGetListLogs) Set(f func(ctx context.Context, pageNumber uint64, pageSize uint64) (lpa1 []*model.Log, err error)) *ChatServerServiceMock {
	if mmGetListLogs.defaultExpectation != nil {
		mmGetListLogs.mock.t.Fatalf("Default expectation is already set for the ChatServerService.GetListLogs method")
	}

	if len(mmGetListLogs.expectations) > 0 {
		mmGetListLogs.mock.t.Fatalf("Some expectations are already set for the ChatServerService.GetListLogs method")
	}

	mmGetListLogs.mock.funcGetListLogs = f
	return mmGetListLogs.mock
}

// When sets expectation for the ChatServerService.GetListLogs which will trigger the result defined by the following
// Then helper
func (mmGetListLogs *mChatServerServiceMockGetListLogs) When(ctx context.Context, pageNumber uint64, pageSize uint64) *ChatServerServiceMockGetListLogsExpectation {
	if mmGetListLogs.mock.funcGetListLogs != nil {
		mmGetListLogs.mock.t.Fatalf("ChatServerServiceMock.GetListLogs mock is already set by Set")
	}

	expectation := &ChatServerServiceMockGetListLogsExpectation{
		mock:   mmGetListLogs.mock,
		params: &ChatServerServiceMockGetListLogsParams{ctx, pageNumber, pageSize},
	}
	mmGetListLogs.expectations = append(mmGetListLogs.expectations, expectation)
	return expectation
}

// Then sets up ChatServerService.GetListLogs return parameters for the expectation previously defined by the When method
func (e *ChatServerServiceMockGetListLogsExpectation) Then(lpa1 []*model.Log, err error) *ChatServerServiceMock {
	e.results = &ChatServerServiceMockGetListLogsResults{lpa1, err}
	return e.mock
}

// GetListLogs implements service.ChatServerService
func (mmGetListLogs *ChatServerServiceMock) GetListLogs(ctx context.Context, pageNumber uint64, pageSize uint64) (lpa1 []*model.Log, err error) {
	mm_atomic.AddUint64(&mmGetListLogs.beforeGetListLogsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListLogs.afterGetListLogsCounter, 1)

	if mmGetListLogs.inspectFuncGetListLogs != nil {
		mmGetListLogs.inspectFuncGetListLogs(ctx, pageNumber, pageSize)
	}

	mm_params := ChatServerServiceMockGetListLogsParams{ctx, pageNumber, pageSize}

	// Record call args
	mmGetListLogs.GetListLogsMock.mutex.Lock()
	mmGetListLogs.GetListLogsMock.callArgs = append(mmGetListLogs.GetListLogsMock.callArgs, &mm_params)
	mmGetListLogs.GetListLogsMock.mutex.Unlock()

	for _, e := range mmGetListLogs.GetListLogsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lpa1, e.results.err
		}
	}

	if mmGetListLogs.GetListLogsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListLogs.GetListLogsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListLogs.GetListLogsMock.defaultExpectation.params
		mm_got := ChatServerServiceMockGetListLogsParams{ctx, pageNumber, pageSize}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListLogs.t.Errorf("ChatServerServiceMock.GetListLogs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListLogs.GetListLogsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListLogs.t.Fatal("No results are set for the ChatServerServiceMock.GetListLogs")
		}
		return (*mm_results).lpa1, (*mm_results).err
	}
	if mmGetListLogs.funcGetListLogs != nil {
		return mmGetListLogs.funcGetListLogs(ctx, pageNumber, pageSize)
	}
	mmGetListLogs.t.Fatalf("Unexpected call to ChatServerServiceMock.GetListLogs. %v %v %v", ctx, pageNumber, pageSize)
	return
}

// GetListLogsAfterCounter returns a count of finished ChatServerServiceMock.GetListLogs invocations
func (mmGetListLogs *ChatServerServiceMock) GetListLogsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListLogs.afterGetListLogsCounter)
}

// GetListLogsBeforeCounter returns a count of ChatServerServiceMock.GetListLogs invocations
func (mmGetListLogs *ChatServerServiceMock) GetListLogsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListLogs.beforeGetListLogsCounter)
}

// Calls returns a list of arguments used in each call to ChatServerServiceMock.GetListLogs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListLogs *mChatServerServiceMockGetListLogs) Calls() []*ChatServerServiceMockGetListLogsParams {
	mmGetListLogs.mutex.RLock()

	argCopy := make([]*ChatServerServiceMockGetListLogsParams, len(mmGetListLogs.callArgs))
	copy(argCopy, mmGetListLogs.callArgs)

	mmGetListLogs.mutex.RUnlock()

	return argCopy
}

// MinimockGetListLogsDone returns true if the count of the GetListLogs invocations corresponds
// the number of defined expectations
func (m *ChatServerServiceMock) MinimockGetListLogsDone() bool {
	for _, e := range m.GetListLogsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListLogsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListLogsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListLogs != nil && mm_atomic.LoadUint64(&m.afterGetListLogsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListLogsInspect logs each unmet expectation
func (m *ChatServerServiceMock) MinimockGetListLogsInspect() {
	for _, e := range m.GetListLogsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerServiceMock.GetListLogs with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListLogsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListLogsCounter) < 1 {
		if m.GetListLogsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerServiceMock.GetListLogs")
		} else {
			m.t.Errorf("Expected call to ChatServerServiceMock.GetListLogs with params: %#v", *m.GetListLogsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListLogs != nil && mm_atomic.LoadUint64(&m.afterGetListLogsCounter) < 1 {
		m.t.Error("Expected call to ChatServerServiceMock.GetListLogs")
	}
}

type mChatServerServiceMockSendMessage struct {
	mock               *ChatServerServiceMock
	defaultExpectation *ChatServerServiceMockSendMessageExpectation
	expectations       []*ChatServerServiceMockSendMessageExpectation

	callArgs []*ChatServerServiceMockSendMessageParams
	mutex    sync.RWMutex
}

// ChatServerServiceMockSendMessageExpectation specifies expectation struct of the ChatServerService.SendMessage
type ChatServerServiceMockSendMessageExpectation struct {
	mock    *ChatServerServiceMock
	params  *ChatServerServiceMockSendMessageParams
	results *ChatServerServiceMockSendMessageResults
	Counter uint64
}

// ChatServerServiceMockSendMessageParams contains parameters of the ChatServerService.SendMessage
type ChatServerServiceMockSendMessageParams struct {
	ctx     context.Context
	message *model.Message
}

// ChatServerServiceMockSendMessageResults contains results of the ChatServerService.SendMessage
type ChatServerServiceMockSendMessageResults struct {
	err error
}

// Expect sets up expected params for ChatServerService.SendMessage
func (mmSendMessage *mChatServerServiceMockSendMessage) Expect(ctx context.Context, message *model.Message) *mChatServerServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServerServiceMockSendMessageExpectation{}
	}

	mmSendMessage.defaultExpectation.params = &ChatServerServiceMockSendMessageParams{ctx, message}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatServerService.SendMessage
func (mmSendMessage *mChatServerServiceMockSendMessage) Inspect(f func(ctx context.Context, message *model.Message)) *mChatServerServiceMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatServerServiceMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatServerService.SendMessage
func (mmSendMessage *mChatServerServiceMockSendMessage) Return(err error) *ChatServerServiceMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServerServiceMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatServerServiceMockSendMessageResults{err}
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatServerService.SendMessage method
func (mmSendMessage *mChatServerServiceMockSendMessage) Set(f func(ctx context.Context, message *model.Message) (err error)) *ChatServerServiceMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatServerService.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatServerService.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the ChatServerService.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatServerServiceMockSendMessage) When(ctx context.Context, message *model.Message) *ChatServerServiceMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerServiceMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatServerServiceMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &ChatServerServiceMockSendMessageParams{ctx, message},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatServerService.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatServerServiceMockSendMessageExpectation) Then(err error) *ChatServerServiceMock {
	e.results = &ChatServerServiceMockSendMessageResults{err}
	return e.mock
}

// SendMessage implements service.ChatServerService
func (mmSendMessage *ChatServerServiceMock) SendMessage(ctx context.Context, message *model.Message) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, message)
	}

	mm_params := ChatServerServiceMockSendMessageParams{ctx, message}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_got := ChatServerServiceMockSendMessageParams{ctx, message}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatServerServiceMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatServerServiceMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, message)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatServerServiceMock.SendMessage. %v %v", ctx, message)
	return
}

// SendMessageAfterCounter returns a count of finished ChatServerServiceMock.SendMessage invocations
func (mmSendMessage *ChatServerServiceMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatServerServiceMock.SendMessage invocations
func (mmSendMessage *ChatServerServiceMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServerServiceMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatServerServiceMockSendMessage) Calls() []*ChatServerServiceMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatServerServiceMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatServerServiceMock) MinimockSendMessageDone() bool {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatServerServiceMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerServiceMock.SendMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerServiceMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to ChatServerServiceMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		m.t.Error("Expected call to ChatServerServiceMock.SendMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServerServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateChatInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockGetListLogsInspect()

			m.MinimockSendMessageInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServerServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServerServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateChatDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockGetListLogsDone() &&
		m.MinimockSendMessageDone()
}
